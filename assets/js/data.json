[
    {
    "id": "5de39b41f8a8fb467c04a7e3",
    "uuid": "3ff61700-90a9-40ca-bccf-72e7d2c149c0",
    "title": "S.O.L.I.D Principle of OOP",
    "slug": "s-o-l-i-d-principle-of-oop",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"In this post, I try to leave out the intricacies of the SOLID principle and write about it succinctly in detail, but yet simple codes samples. Let’s get started\\n\\nThe SOLID principle is a design pattern that enables and disciplines us to write reusable, decoupled, and maintainable code. That is as simple as it can get.\\n\\nNow, we know what the  SOLID principles want to get out of us, let’s briefly talk about what makes a code SOLID.  SOLID codes have to satisfy SOLID principle checklist which leads us to the SOLID acronym and what it means.\\n\\n* S: Single Responsible Principle (SRP)\\n* O: Open Closed Principle (OSP)\\n* L: Liskov Substituion Principle\\n* I: Interface Segregation Principle (ISP)\\n* D: Dependency Inversion Principle (DIP)\\n\\n   \\n\\nLet’s go throw each with code walkthrough\\n\\n## S: Single Responsible Principle (SRP)\\n> *<p class=\\\"strong-point-highlight\\\">A class should have only one reason to change</p>*\\n\\nSRP says that a class should focus on one specific thing rather than do multiple things.  The SRP simple does not mean a class should have only one method, but everything the class does should revolve around one thing.\\nFor example, a <b>Person</b> class might have the responsibility of carrying out a various operation such as creating a new person’s record, update, delete,  and retrieve from a data store. The class can also be tasked on how to present information to a user such as print, display, sending email, logging etc. \\n\\nMixing up responsibility makes a class unmaintainable, challenging to understand and makes writing unit tests a nightmare because the responsibilities cannot be separated and thus ultimately violates SRP.  \\n\\n<p class=\\\"space\\\"></p>\\n\\nLet’s see an example of SRP violation:  \\n\\n<pre><code class=\\\"lang-cs\\\">\\n    public class Person\\n    {\\n        public Guid PersonId { get; set; }\\n        public string FirstName { get; set; }\\n        public string LastName { get; set; }\\n        private decimal Salary { get; set; }\\n\\n        private string Mydocpath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\\n\\n        public string FullName()\\n        {\\n            return $\\\"{FirstName} - {LastName}\\\";\\n        }\\n\\n        public decimal GetSalary()\\n        {\\n            return this.Salary;\\n        }\\n\\n        public void IncreaseSalary(decimal percentage)\\n        {\\n            this.Salary += this.Salary * percentage;\\n        }\\n\\n        public void SavePerson()\\n        {\\n            try\\n            {\\n                // code for saving person to a data store\\n\\n                //After a person has been saved, we send confirmation email\\n                var mailMessage = new MailMessage(\\\"MailFrom\\\", \\\"MailTo\\\", \\\"Subject\\\", \\\"Body\\\");\\n                this.SendEmail(mailMessage);\\n\\n            }\\n            catch (Exception e)\\n            {\\n                System.IO.File.WriteAllText(this.Mydocpath + @\\\"\\\\Exceptionsfile.txt\\\", e.ToString());\\n            }\\n        }\\n\\n        public void SendEmail(MailMessage mail)\\n        {\\n            try\\n            {\\n                // Code for getting Email setting and send mail\\n            }\\n            catch (Exception e)\\n            {\\n                System.IO.File.WriteAllText(this.Mydocpath + @\\\"\\\\Exceptionsfile.txt\\\", e.ToString());\\n            }\\n        }\\n\\n    }\\n</code></pre>\\n   \\n   \\n   \\n  The *Person* class violates SRP, as it behaves like a God Object. A *God Object* is a class which does everything. An example of a *God Object* is this:\\n  \\n![swiss army knife](http://static.everypixel.com/ep-pixabay/1818/9349/2262/83574/18189349226283574929-swiss_army_knife.jpg)  \\n\\n\\nThe Swiss army knife in the pictures does so much than just being a pocket tool. It can also store your files <i class=\\\"far fa-smile\\\"></i>. \\n  \\nBack to the *Person* class which carries out own responsibilities such as get full name, get a salary, increase salary and also sending emails and logging as well.\\n\\nThe *==\\\"A class should have only one reason to change\\\"==* will not be met if for example, you want to modify the email, logging functionalities or perhaps writing a unit test to test each feature.\\n \\n\\n### Solution:\\nLet's refactor the code to satisfy SRP\\n\\n\\n<pre><code class=\\\"cs\\\">\\n    public class Person\\n    {\\n        public Guid PersonId { get; set; }\\n        public string FirstName { get; set; }\\n        public string LastName { get; set; }\\n        private decimal Salary { get; set; }\\n\\n        private FileLogger fileLogger;\\n        private MailSender mailSender;\\n\\n\\n        public Person()\\n        {\\n            fileLogger = new FileLogger();\\n            mailSender = new MailSender();\\n        }\\n\\n        public string FullName()\\n        {\\n            return $\\\"{FirstName} - {LastName}\\\";\\n        }\\n\\n        public decimal GetSalary()\\n        {\\n            return this.Salary;\\n        }\\n\\n        public void IncreaseSalary(decimal percentage)\\n        {\\n            this.Salary += this.Salary * percentage;\\n        }\\n\\n        public void SavePerson()\\n        {\\n            try\\n            {\\n                // code for saving person to a data store\\n\\n                //After a person has been saved, we send confirmation email\\n                //Abstracting away how email is being sent\\n                fileLogger.Info(\\\"Add method Start\\\");\\n                // Code for adding invoice\\n                // Once Invoice has been added , send mail \\n                mailSender.From = \\\"contact@gmail.com\\\";\\n                mailSender.To = \\\"recipient@google.com\\\";\\n                mailSender.Subject = \\\"Verification\\\";\\n                mailSender.Body = \\\"This is an email message for Bob and Alice\\\";\\n                mailSender.SendEmail();\\n            }\\n            catch (Exception e)\\n            {\\n                fileLogger.Error(\\\"Exception message\\\", e);\\n            }\\n        }\\n\\n    }\\n\\n\\n\\n\\n    public interface ILogger\\n    {\\n        void Info(string info);\\n        void Debug(string info);\\n        void Error(string info, Exception e);\\n    }\\n\\n    public class FileLogger : ILogger\\n    {\\n        private string MyDocpath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\\n\\n        public FileLogger()\\n        {\\n            //Initialization code(s)\\n        }\\n\\n        public void Info(string info)\\n        {\\n            // Code for details to text file \\n        }\\n\\n        public void Debug(string info)\\n        {\\n            // Code for debug information to text file \\n        }\\n\\n        public void Error(string message, Exception ex)\\n        {\\n            // Code for erros with message and exception details\\n        }\\n    }\\n\\n\\n    public class MailSender\\n    {\\n        public string From { get; set; }\\n        public string To { get; set; }\\n        public string Subject { get; set; }\\n        public string Body { get; set; }\\n\\n        public void SendEmail()\\n        {\\n            // Code for sending mail\\n        }\\n    }\\n</code></pre>\\n\\nNow the *Person* class can focus on what it knows how to do best, and that is how to create, save, calculate salary about a user and cares less about sending emails or logging hence satisfies the *==Single Responsibility Princciple==*. The other tasks of logging and email sending are delegated to the responsible classes separating the concerns and responsibilities.\\n\\n<p class=\\\"space\\\"></p>\\n\\n## O: Open Closed Principle (OSP)\\n\\n> *<p class=\\\"strong-point-highlight\\\">Software entities (classes, modules, functions, etc) should be open for extension , but closed for modification.</p>*\\n\\nTo put it in a simple sentence, ==change a class behaviour using inheritance and composition.==  \\n\\n==\\\"Open for extension\\\"== means we ought to design our classes in a way that will allow new feature or functionality to be added when new requirements arise or a change of request comes up. ==\\\"Closed for modification means\\\"== we should not alter codes that have already gone through design, coding, unit testing and it is in-production unless it is a bug. \\n\\nLet's demonstrate OSP using codes using a ==*Shape*== class.\\n\\n\\nOSP violation:  \\n\\n<pre><code class=\\\"cs\\\">\\n    public enum ShapeType\\n    {\\n        Triangle, Rectangle, Circle\\n    }\\n\\n    public class Shape\\n    {\\n        public ShapeType ShapeType { get; set; }\\n        public double Width { get; set; }\\n        public double Height { get; set; }\\n\\n        public string CalculateArea( )\\n        {\\n            var calculatedArea = default(double);\\n\\n            if (ShapeType == ShapeType.Triangle)\\n            {\\n                calculatedArea =  Height * Width;\\n            }else if (ShapeType == ShapeType.Triangle)\\n            {\\n                calculatedArea = 0.5 * Width * Height;\\n            }\\n            else if(ShapeType == ShapeType.Circle)\\n            {\\n                calculatedArea = Math.PI * Math.Pow(Height, 2);\\n            }\\n\\n            return calculatedArea.ToString(CultureInfo.InvariantCulture);\\n        }\\n    }\\n</code></pre>\\n\\nNow, this simple ==*Shape*== class represents a shape and calculates its area. This scenario will work well without issues only if we have to calculate only three shapes, Triangle, Rectangle Circle. What if we need to calculate the area of a sphere tomorrow or a rhombus? We will have to alter the ==*Shape*== class and add one or more if condition to satisfy the requirement and equally alter the enum to add the new type of shape. Adding more if conditions to cater to new shapes will quickly run out of hands and make the code unmaintainable and difficult to test. Hence, the class is not ==\\\"closed for modification\\\"==.    \\n\\n<p class=\\\"space\\\"></p>\\n\\nLet's make the ==*Shape*== class \\\"Open for extension, but closed for modification\\\" hence satisfying OSP.  \\n\\n\\n#### OSP solution:  \\n\\n<pre><code>\\n    public abstract class Shape\\n    {\\n        public abstract double CalculateArea();\\n    }\\n\\n\\n    public class Triangle : Shape\\n    {\\n        public double Base { get; set; }\\n        public double Height { get; set; }\\n\\n        public override double CalculateArea()\\n        {\\n            return 0.5 * Base * Height;\\n        }\\n    }\\n\\n\\n    public class Cirle : Shape\\n    {\\n        public double Radius { get; set; }\\n        public override double CalculateArea()\\n        {\\n            return Math.PI * (Radius * Radius);\\n        }\\n    }\\n</code></pre>\\n\\n\\nNow that looks much better. The ==*Shape*== class is now closed for modification because to add a new feature of calculating a new shape, we don't alter or modify the Shape class. Instead, we extended it by using inheritance.  \\n\\nExtending the Shape class further by adding the rhombus shape will look like this:  \\n\\n\\n<pre><code>\\n    public class Rhombus : Shape\\n    {\\n        public double Diagonal { get; set; }\\n        public override double CalculateArea()\\n        {\\n            return (1/2) * Diagonal * Diagonal;\\n        }\\n    }\\n</code></pre>\\n\\nViola! we have satisfied OSP.  \\n\\n<p class=\\\"space\\\"></p>\\n<p class=\\\"space\\\"></p>\\n\\n## L: Liskov Substitution Principle (LSP)\\n> *<p class=\\\"strong-point-highlight\\\">Objects in a program should be replacable with instances of their subtypes without altering the correctness of the that program.</p>*  \\n\\n\\nIn a simple translation, a child class can replace a parent class in a code, and it should not break that code. e.g. If class Dog is a child(derived class) of class Animal(base class), then instances of Dog can replace the instance of Animal without issue. Liskov substitution principle goes a bit deeper, but for a simple explanation is a good starting position.  \\n\\n__Note:__ ==*LSP is about honoring contracts and not intending to change the behaviour of a base class.*==  \\n\\n\\nThe code below violates LSP in that derived class Square changed the behaviour of the base class.\\n\\nViolation of LSP: \\n\\n<pre><code>\\n    public class Rectangle\\n    {\\n        public virtual Int32 Height { get; set; }\\n        public virtual Int32 Width { get; set; }\\n\\n        public virtual void CalculateArea()\\n        {\\n            Console.WriteLine($\\\"The area is: {Height * Width}\\\");\\n        }\\n    }\\n\\n    public class Square : Rectangle\\n    {\\n        public override Int32 Height\\n        {\\n            get => base.Height;\\n            set => SetDimensions(value);\\n        }\\n\\n        public override Int32 Width\\n        {\\n            get => base.Width;\\n            set => SetDimensions(value);\\n        }\\n\\n        private void SetDimensions(Int32 value)\\n        {\\n            base.Height = value;\\n            base.Width = value;\\n        }\\n    }\\n</code></pre>  \\n\\nGiving the above code, a quick run, the output says The area is 9, which is correct as the area of a square is (width)<sup>2</sup>. <span class=\\\"text-danger\\\">But!</span> this violates the LSP that states that a derived class should replace a base class without breaking or altering the program.\\n\\n<pre><code>\\n    static void Main(string[] args)\\n    {\\n        Rectangle rectangle = new Square();\\n        rectangle.Height = 2;\\n        rectangle.Width = 3;\\n\\n        rectangle.CalculateArea(); // The area is 9\\n        Console.ReadKey();\\n    }\\n</code></pre>  \\n\\nLet implement the code to become LSP compliant. The solution to this problem is not straightforward, but let have a look. Remember the OCP, if a code is OCP complaint, that code is more likely to be LSP compliant as well. ==*As a rule of thumb, try to move implementation that may differ to the derived classes and leave the more general implementation to the base class.*==\\n\\n<pre><code>\\n    public interface IShape\\n    {\\n        void CalculateArea();\\n    }\\n\\n    public class Square : IShape\\n    {\\n        public double Width { get; set; }\\n        public void CalculateArea()\\n        {\\n            Console.WriteLine($\\\"The area is {Math.Pow(Width, 2)}\\\");\\n        }\\n    }\\n\\n    public class Rhombus : IShape\\n    {\\n        public double Diagonal { get; set; }\\n        public void CalculateArea()\\n        {\\n            Console.WriteLine($\\\"The area is: {(1 / 2) * Diagonal * Diagonal}\\\");\\n        }\\n    }\\n</code></pre>    \\n\\nThe base class IShape contract is now implemented by Square and Rhombus with no violation by not allowing the subclasses to change the behaviour of the base class. \\n\\n__Important:__ If a code is OSP complaint, it is likely, it is  LSP complaint as both go hand in hand.\\n\\n\\n\\n<p class=\\\"space\\\"></p>\\n<p class=\\\"space\\\"></p>\\n\\n## I: Interface Segregation Principle (ISP)\\n> *<p class=\\\"strong-point-highlight\\\">No client should be forced to depend on methods it does not need. Split large interfaces into smaller and more specific ones so clients can pick and choose methods that are of interest to them.</p>*  \\n\\nIn a simple sentence, this means a derived class should only implement what it needs and not all methods in the parent class or interface.  \\n\\nUsing the analogy of a manager, a lead developer, and a developer.\\n\\nViolation of ISP:\\n\\n<pre><code>\\n    public interface ILead\\n    {\\n        void CreateSubTask();\\n        void AssginTask();\\n        void WorkOnTask();\\n    }\\n\\n    public class Developer : ILead\\n    {\\n        public void CreateSubTask()\\n        {\\n            throw new Exception(\\\"Cannot create subtasks\\\");\\n        }\\n\\n        public void AssginTask()\\n        {\\n            throw new Exception(\\\"Cannot assign tasks\\\");\\n        }\\n\\n        public void WorkOnTask()\\n        {\\n            //codes to implement working on tasks\\n        }\\n    }\\n\\n    public class LeadDeveloper : ILead\\n    {\\n        public void CreateSubTask()\\n        {\\n            //code to create subtasks\\n        }\\n\\n        public void AssginTask()\\n        {\\n            //code to assign tasks\\n        }\\n\\n        public void WorkOnTask()\\n        {\\n            //codes to implement working on tasks\\n        }\\n    }\\n\\n    public class Manager : ILead\\n    {\\n        public void CreateSubTask()\\n        {\\n            //code to create subtasks\\n        }\\n\\n        public void AssginTask()\\n        {\\n            //code to assign tasks\\n        }\\n\\n        public void WorkOnTask()\\n        {\\n            throw new Exception(\\\"Manager cannot work on programming tasks\\\");\\n        }\\n    }\\n</code></pre>    \\n\\nWe have three roles in that a Manager cannot work on tasks and no can assign a task to a manger aside from the manager's boss if there's another layer of hierarchy. But the Manager implements the ==WorkOnTask()== method it doesn't need. Same for the Developer class, a developer cannot create subtasks and assign tasks hence should not be implementing both methods. As for the LeadDeveloper, it implements all method on the ILead interface as needed.\\n\\n###Solution:\\nThe solution is to split the interfaces into manageable chunks to clients can pick and choose what they need to implement.\\n\\n<pre><code>\\n    public interface ILead\\n    {\\n        void CreateSubTask();\\n        void AssginTask();\\n    }\\n\\n    public interface IProgrammer\\n    {\\n        void WorkOnTask();\\n    }\\n\\n    public class Developer : IProgrammer\\n    {\\n        public void WorkOnTask()\\n        {\\n            //codes to implement working on tasks\\n        }\\n    }\\n\\n    public class LeadDeveloper : ILead, IProgrammer\\n    {\\n        public void CreateSubTask()\\n        {\\n            //code to create subtasks\\n        }\\n\\n        public void AssginTask()\\n        {\\n            //code to assign tasks\\n        }\\n\\n        public void WorkOnTask()\\n        {\\n            //codes to implement working on tasks\\n        }\\n    }\\n\\n    public class Manager : ILead\\n    {\\n        public void CreateSubTask()\\n        {\\n            //code to create subtasks\\n        }\\n\\n        public void AssginTask()\\n        {\\n            //code to assign tasks\\n        }\\n    }\\n</code></pre>  \\n\\n\\n<p class=\\\"space\\\"></p>\\n<p class=\\\"space\\\"></p>\\n\\n## D: Dependency Inversion Principle (DIP)\\n> *<p class=\\\"strong-point-highlight\\\">High level modules should not depend on low level modules, Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions</p>* \\n\\nIn a simple sentence, high-level modules and low-level module should be loosely coupled as much as possible. They need not know the detail implementation of each other, in other words, they should depend on a contract.  \\n\\nLet's use the example of a notification system where we can either send Email, SMS or Mail depending on a user choosing. Alternatively, all three if the user opt-in for all.\\n\\n\\n####Violation of DIP:\\n\\n<pre><code>\\n    public class Email\\n    {\\n        public string ToAddress { get; set; }\\n        public string Subject { get; set; }\\n        public string Content { get; set; }\\n        public void SendEmail()\\n        {\\n            //Send email\\n        }\\n    }\\n\\n    public class SMS\\n    {\\n        public string PhoneNumber { get; set; }\\n        public string Message { get; set; }\\n        public void SendSMS()\\n        {\\n            //Send sms\\n        }\\n    }\\n    \\n    public class Mail\\n    {\\n        public string Address { get; set; }\\n        public string Message { get; set; }\\n        public void SendMail()\\n        {\\n            //Send Mail by post\\n        }\\n    }\\n    \\n    public class Notification\\n    {\\n        private Email _email;\\n        private SMS _sms;\\n        private Mail _mail;\\n        public Notification()\\n        {\\n            _email = new Email();\\n            _sms = new SMS();\\n            _mail = new Mail();\\n        }\\n\\n        public void Send()\\n        {\\n            _email.SendEmail();\\n            _sms.SendSMS();\\n            _mail.SendMail();\\n        }\\n    }\\n</code></pre>    \\n\\nAs we can see from the code sample above, the higher-level (Notification) module has dependencies on Email, SMS, and Mail modules, which are lower-level modules which violate DIP, and the also violates Single Responsibility Principle.\\n\\n####Solution:\\n\\n<pre><code>\\n    public interface IMessage\\n    {\\n        void SendMessage();\\n    }\\n    \\n    public class Email : IMessage\\n    {\\n        public string ToAddress { get; set; }\\n        public string Subject { get; set; }\\n        public string Content { get; set; }\\n        public void SendMessage()\\n        {\\n            //Send Email\\n        }\\n    }\\n\\n    public class SMS : IMessage\\n    {\\n        public string PhoneNumber { get; set; }\\n        public string Message { get; set; }\\n        public void SendMessage()\\n        {\\n            //Send SMS\\n        }\\n    }\\n    \\n    public class Mail : IMessage\\n    {\\n        public string Address { get; set; }\\n        public string Message { get; set; }\\n        public void SendMessage()\\n        {\\n            //Send Mail by post\\n        }\\n    }\\n</code></pre>  \\n\\n\\nThe Notification system can now do one thing and one thing only. Send message without bothering about the implementation details, but depend on abstraction.\\n\\n<pre><code>\\n    public class Notification\\n    {\\n        private ICollection<IMessage> _messages;\\n\\n        public Notification(ICollection<IMessage> messages)\\n        {\\n            this._messages = messages;\\n        }\\n        public void SendMessage()\\n        {\\n            foreach(var message in _messages)\\n            {\\n                message.SendMessage();\\n            }\\n        }\\n    }\\n</code></pre> \\n\\n\\nThis concludes __SOLID__ principles. Hope you've learned something today. Happy Coding!\"}]],\"markups\":[],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>In this post, I try to leave out the intricacies of the SOLID principle and write about it succinctly in detail, but yet simple codes samples. Let’s get started</p>\n<p>The SOLID principle is a design pattern that enables and disciplines us to write reusable, decoupled, and maintainable code. That is as simple as it can get.</p>\n<p>Now, we know what the  SOLID principles want to get out of us, let’s briefly talk about what makes a code SOLID.  SOLID codes have to satisfy SOLID principle checklist which leads us to the SOLID acronym and what it means.</p>\n<ul>\n<li>S: Single Responsible Principle (SRP)</li>\n<li>O: Open Closed Principle (OSP)</li>\n<li>L: Liskov Substituion Principle</li>\n<li>I: Interface Segregation Principle (ISP)</li>\n<li>D: Dependency Inversion Principle (DIP)</li>\n</ul>\n<p>Let’s go throw each with code walkthrough</p>\n<h2 id=\"ssingleresponsibleprinciplesrp\">S: Single Responsible Principle (SRP)</h2>\n<blockquote>\n<p><em><p class=\"strong-point-highlight\">A class should have only one reason to change</p></em></p>\n</blockquote>\n<p>SRP says that a class should focus on one specific thing rather than do multiple things.  The SRP simple does not mean a class should have only one method, but everything the class does should revolve around one thing.<br>\nFor example, a <b>Person</b> class might have the responsibility of carrying out a various operation such as creating a new person’s record, update, delete,  and retrieve from a data store. The class can also be tasked on how to present information to a user such as print, display, sending email, logging etc.</p>\n<p>Mixing up responsibility makes a class unmaintainable, challenging to understand and makes writing unit tests a nightmare because the responsibilities cannot be separated and thus ultimately violates SRP.</p>\n<p class=\"space\"></p>\n<p>Let’s see an example of SRP violation:</p>\n<pre><code class=\"lang-cs\">\n    public class Person\n    {\n        public Guid PersonId { get; set; }\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        private decimal Salary { get; set; }\n\n        private string Mydocpath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\n\n        public string FullName()\n        {\n            return $\"{FirstName} - {LastName}\";\n        }\n\n        public decimal GetSalary()\n        {\n            return this.Salary;\n        }\n\n        public void IncreaseSalary(decimal percentage)\n        {\n            this.Salary += this.Salary * percentage;\n        }\n\n        public void SavePerson()\n        {\n            try\n            {\n                // code for saving person to a data store\n\n                //After a person has been saved, we send confirmation email\n                var mailMessage = new MailMessage(\"MailFrom\", \"MailTo\", \"Subject\", \"Body\");\n                this.SendEmail(mailMessage);\n\n            }\n            catch (Exception e)\n            {\n                System.IO.File.WriteAllText(this.Mydocpath + @\"\\Exceptionsfile.txt\", e.ToString());\n            }\n        }\n\n        public void SendEmail(MailMessage mail)\n        {\n            try\n            {\n                // Code for getting Email setting and send mail\n            }\n            catch (Exception e)\n            {\n                System.IO.File.WriteAllText(this.Mydocpath + @\"\\Exceptionsfile.txt\", e.ToString());\n            }\n        }\n\n    }\n</code></pre>\n<p>The <em>Person</em> class violates SRP, as it behaves like a God Object. A <em>God Object</em> is a class which does everything. An example of a <em>God Object</em> is this:</p>\n<p><img src=\"http://static.everypixel.com/ep-pixabay/1818/9349/2262/83574/18189349226283574929-swiss_army_knife.jpg\" alt=\"swiss army knife\"></p>\n<p>The Swiss army knife in the pictures does so much than just being a pocket tool. It can also store your files <i class=\"far fa-smile\"></i>.</p>\n<p>Back to the <em>Person</em> class which carries out own responsibilities such as get full name, get a salary, increase salary and also sending emails and logging as well.</p>\n<p>The <em><mark>&quot;A class should have only one reason to change&quot;</mark></em> will not be met if for example, you want to modify the email, logging functionalities or perhaps writing a unit test to test each feature.</p>\n<h3 id=\"solution\">Solution:</h3>\n<p>Let's refactor the code to satisfy SRP</p>\n<pre><code class=\"cs\">\n    public class Person\n    {\n        public Guid PersonId { get; set; }\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        private decimal Salary { get; set; }\n\n        private FileLogger fileLogger;\n        private MailSender mailSender;\n\n\n        public Person()\n        {\n            fileLogger = new FileLogger();\n            mailSender = new MailSender();\n        }\n\n        public string FullName()\n        {\n            return $\"{FirstName} - {LastName}\";\n        }\n\n        public decimal GetSalary()\n        {\n            return this.Salary;\n        }\n\n        public void IncreaseSalary(decimal percentage)\n        {\n            this.Salary += this.Salary * percentage;\n        }\n\n        public void SavePerson()\n        {\n            try\n            {\n                // code for saving person to a data store\n\n                //After a person has been saved, we send confirmation email\n                //Abstracting away how email is being sent\n                fileLogger.Info(\"Add method Start\");\n                // Code for adding invoice\n                // Once Invoice has been added , send mail \n                mailSender.From = \"contact@gmail.com\";\n                mailSender.To = \"recipient@google.com\";\n                mailSender.Subject = \"Verification\";\n                mailSender.Body = \"This is an email message for Bob and Alice\";\n                mailSender.SendEmail();\n            }\n            catch (Exception e)\n            {\n                fileLogger.Error(\"Exception message\", e);\n            }\n        }\n\n    }\n\n\n\n\n    public interface ILogger\n    {\n        void Info(string info);\n        void Debug(string info);\n        void Error(string info, Exception e);\n    }\n\n    public class FileLogger : ILogger\n    {\n        private string MyDocpath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\n\n        public FileLogger()\n        {\n            //Initialization code(s)\n        }\n\n        public void Info(string info)\n        {\n            // Code for details to text file \n        }\n\n        public void Debug(string info)\n        {\n            // Code for debug information to text file \n        }\n\n        public void Error(string message, Exception ex)\n        {\n            // Code for erros with message and exception details\n        }\n    }\n\n\n    public class MailSender\n    {\n        public string From { get; set; }\n        public string To { get; set; }\n        public string Subject { get; set; }\n        public string Body { get; set; }\n\n        public void SendEmail()\n        {\n            // Code for sending mail\n        }\n    }\n</code></pre>\n<p>Now the <em>Person</em> class can focus on what it knows how to do best, and that is how to create, save, calculate salary about a user and cares less about sending emails or logging hence satisfies the <em><mark>Single Responsibility Princciple</mark></em>. The other tasks of logging and email sending are delegated to the responsible classes separating the concerns and responsibilities.</p>\n<p class=\"space\"></p>\n<h2 id=\"oopenclosedprincipleosp\">O: Open Closed Principle (OSP)</h2>\n<blockquote>\n<p><em><p class=\"strong-point-highlight\">Software entities (classes, modules, functions, etc) should be open for extension , but closed for modification.</p></em></p>\n</blockquote>\n<p>To put it in a simple sentence, <mark>change a class behaviour using inheritance and composition.</mark></p>\n<p><mark>&quot;Open for extension&quot;</mark> means we ought to design our classes in a way that will allow new feature or functionality to be added when new requirements arise or a change of request comes up. <mark>&quot;Closed for modification means&quot;</mark> we should not alter codes that have already gone through design, coding, unit testing and it is in-production unless it is a bug.</p>\n<p>Let's demonstrate OSP using codes using a <mark><em>Shape</em></mark> class.</p>\n<p>OSP violation:</p>\n<pre><code class=\"cs\">\n    public enum ShapeType\n    {\n        Triangle, Rectangle, Circle\n    }\n\n    public class Shape\n    {\n        public ShapeType ShapeType { get; set; }\n        public double Width { get; set; }\n        public double Height { get; set; }\n\n        public string CalculateArea( )\n        {\n            var calculatedArea = default(double);\n\n            if (ShapeType == ShapeType.Triangle)\n            {\n                calculatedArea =  Height * Width;\n            }else if (ShapeType == ShapeType.Triangle)\n            {\n                calculatedArea = 0.5 * Width * Height;\n            }\n            else if(ShapeType == ShapeType.Circle)\n            {\n                calculatedArea = Math.PI * Math.Pow(Height, 2);\n            }\n\n            return calculatedArea.ToString(CultureInfo.InvariantCulture);\n        }\n    }\n</code></pre>\n<p>Now, this simple <mark><em>Shape</em></mark> class represents a shape and calculates its area. This scenario will work well without issues only if we have to calculate only three shapes, Triangle, Rectangle Circle. What if we need to calculate the area of a sphere tomorrow or a rhombus? We will have to alter the <mark><em>Shape</em></mark> class and add one or more if condition to satisfy the requirement and equally alter the enum to add the new type of shape. Adding more if conditions to cater to new shapes will quickly run out of hands and make the code unmaintainable and difficult to test. Hence, the class is not <mark>&quot;closed for modification&quot;</mark>.</p>\n<p class=\"space\"></p>\n<p>Let's make the <mark><em>Shape</em></mark> class &quot;Open for extension, but closed for modification&quot; hence satisfying OSP.</p>\n<h4 id=\"ospsolution\">OSP solution:</h4>\n<pre><code>\n    public abstract class Shape\n    {\n        public abstract double CalculateArea();\n    }\n\n\n    public class Triangle : Shape\n    {\n        public double Base { get; set; }\n        public double Height { get; set; }\n\n        public override double CalculateArea()\n        {\n            return 0.5 * Base * Height;\n        }\n    }\n\n\n    public class Cirle : Shape\n    {\n        public double Radius { get; set; }\n        public override double CalculateArea()\n        {\n            return Math.PI * (Radius * Radius);\n        }\n    }\n</code></pre>\n<p>Now that looks much better. The <mark><em>Shape</em></mark> class is now closed for modification because to add a new feature of calculating a new shape, we don't alter or modify the Shape class. Instead, we extended it by using inheritance.</p>\n<p>Extending the Shape class further by adding the rhombus shape will look like this:</p>\n<pre><code>\n    public class Rhombus : Shape\n    {\n        public double Diagonal { get; set; }\n        public override double CalculateArea()\n        {\n            return (1/2) * Diagonal * Diagonal;\n        }\n    }\n</code></pre>\n<p>Viola! we have satisfied OSP.</p>\n<p class=\"space\"></p>\n<p class=\"space\"></p>\n<h2 id=\"lliskovsubstitutionprinciplelsp\">L: Liskov Substitution Principle (LSP)</h2>\n<blockquote>\n<p><em><p class=\"strong-point-highlight\">Objects in a program should be replacable with instances of their subtypes without altering the correctness of the that program.</p></em></p>\n</blockquote>\n<p>In a simple translation, a child class can replace a parent class in a code, and it should not break that code. e.g. If class Dog is a child(derived class) of class Animal(base class), then instances of Dog can replace the instance of Animal without issue. Liskov substitution principle goes a bit deeper, but for a simple explanation is a good starting position.</p>\n<p><strong>Note:</strong> <mark><em>LSP is about honoring contracts and not intending to change the behaviour of a base class.</em></mark></p>\n<p>The code below violates LSP in that derived class Square changed the behaviour of the base class.</p>\n<p>Violation of LSP:</p>\n<pre><code>\n    public class Rectangle\n    {\n        public virtual Int32 Height { get; set; }\n        public virtual Int32 Width { get; set; }\n\n        public virtual void CalculateArea()\n        {\n            Console.WriteLine($\"The area is: {Height * Width}\");\n        }\n    }\n\n    public class Square : Rectangle\n    {\n        public override Int32 Height\n        {\n            get => base.Height;\n            set => SetDimensions(value);\n        }\n\n        public override Int32 Width\n        {\n            get => base.Width;\n            set => SetDimensions(value);\n        }\n\n        private void SetDimensions(Int32 value)\n        {\n            base.Height = value;\n            base.Width = value;\n        }\n    }\n</code></pre>  \n<p>Giving the above code, a quick run, the output says The area is 9, which is correct as the area of a square is (width)<sup>2</sup>. <span class=\"text-danger\">But!</span> this violates the LSP that states that a derived class should replace a base class without breaking or altering the program.</p>\n<pre><code>\n    static void Main(string[] args)\n    {\n        Rectangle rectangle = new Square();\n        rectangle.Height = 2;\n        rectangle.Width = 3;\n\n        rectangle.CalculateArea(); // The area is 9\n        Console.ReadKey();\n    }\n</code></pre>  \n<p>Let implement the code to become LSP compliant. The solution to this problem is not straightforward, but let have a look. Remember the OCP, if a code is OCP complaint, that code is more likely to be LSP compliant as well. <mark><em>As a rule of thumb, try to move implementation that may differ to the derived classes and leave the more general implementation to the base class.</em></mark></p>\n<pre><code>\n    public interface IShape\n    {\n        void CalculateArea();\n    }\n\n    public class Square : IShape\n    {\n        public double Width { get; set; }\n        public void CalculateArea()\n        {\n            Console.WriteLine($\"The area is {Math.Pow(Width, 2)}\");\n        }\n    }\n\n    public class Rhombus : IShape\n    {\n        public double Diagonal { get; set; }\n        public void CalculateArea()\n        {\n            Console.WriteLine($\"The area is: {(1 / 2) * Diagonal * Diagonal}\");\n        }\n    }\n</code></pre>    \n<p>The base class IShape contract is now implemented by Square and Rhombus with no violation by not allowing the subclasses to change the behaviour of the base class.</p>\n<p><strong>Important:</strong> If a code is OSP complaint, it is likely, it is  LSP complaint as both go hand in hand.</p>\n<p class=\"space\"></p>\n<p class=\"space\"></p>\n<h2 id=\"iinterfacesegregationprincipleisp\">I: Interface Segregation Principle (ISP)</h2>\n<blockquote>\n<p><em><p class=\"strong-point-highlight\">No client should be forced to depend on methods it does not need. Split large interfaces into smaller and more specific ones so clients can pick and choose methods that are of interest to them.</p></em></p>\n</blockquote>\n<p>In a simple sentence, this means a derived class should only implement what it needs and not all methods in the parent class or interface.</p>\n<p>Using the analogy of a manager, a lead developer, and a developer.</p>\n<p>Violation of ISP:</p>\n<pre><code>\n    public interface ILead\n    {\n        void CreateSubTask();\n        void AssginTask();\n        void WorkOnTask();\n    }\n\n    public class Developer : ILead\n    {\n        public void CreateSubTask()\n        {\n            throw new Exception(\"Cannot create subtasks\");\n        }\n\n        public void AssginTask()\n        {\n            throw new Exception(\"Cannot assign tasks\");\n        }\n\n        public void WorkOnTask()\n        {\n            //codes to implement working on tasks\n        }\n    }\n\n    public class LeadDeveloper : ILead\n    {\n        public void CreateSubTask()\n        {\n            //code to create subtasks\n        }\n\n        public void AssginTask()\n        {\n            //code to assign tasks\n        }\n\n        public void WorkOnTask()\n        {\n            //codes to implement working on tasks\n        }\n    }\n\n    public class Manager : ILead\n    {\n        public void CreateSubTask()\n        {\n            //code to create subtasks\n        }\n\n        public void AssginTask()\n        {\n            //code to assign tasks\n        }\n\n        public void WorkOnTask()\n        {\n            throw new Exception(\"Manager cannot work on programming tasks\");\n        }\n    }\n</code></pre>    \n<p>We have three roles in that a Manager cannot work on tasks and no can assign a task to a manger aside from the manager's boss if there's another layer of hierarchy. But the Manager implements the <mark>WorkOnTask()</mark> method it doesn't need. Same for the Developer class, a developer cannot create subtasks and assign tasks hence should not be implementing both methods. As for the LeadDeveloper, it implements all method on the ILead interface as needed.</p>\n<h3 id=\"solution\">Solution:</h3>\n<p>The solution is to split the interfaces into manageable chunks to clients can pick and choose what they need to implement.</p>\n<pre><code>\n    public interface ILead\n    {\n        void CreateSubTask();\n        void AssginTask();\n    }\n\n    public interface IProgrammer\n    {\n        void WorkOnTask();\n    }\n\n    public class Developer : IProgrammer\n    {\n        public void WorkOnTask()\n        {\n            //codes to implement working on tasks\n        }\n    }\n\n    public class LeadDeveloper : ILead, IProgrammer\n    {\n        public void CreateSubTask()\n        {\n            //code to create subtasks\n        }\n\n        public void AssginTask()\n        {\n            //code to assign tasks\n        }\n\n        public void WorkOnTask()\n        {\n            //codes to implement working on tasks\n        }\n    }\n\n    public class Manager : ILead\n    {\n        public void CreateSubTask()\n        {\n            //code to create subtasks\n        }\n\n        public void AssginTask()\n        {\n            //code to assign tasks\n        }\n    }\n</code></pre>  \n<p class=\"space\"></p>\n<p class=\"space\"></p>\n<h2 id=\"ddependencyinversionprincipledip\">D: Dependency Inversion Principle (DIP)</h2>\n<blockquote>\n<p><em><p class=\"strong-point-highlight\">High level modules should not depend on low level modules, Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions</p></em></p>\n</blockquote>\n<p>In a simple sentence, high-level modules and low-level module should be loosely coupled as much as possible. They need not know the detail implementation of each other, in other words, they should depend on a contract.</p>\n<p>Let's use the example of a notification system where we can either send Email, SMS or Mail depending on a user choosing. Alternatively, all three if the user opt-in for all.</p>\n<h4 id=\"violationofdip\">Violation of DIP:</h4>\n<pre><code>\n    public class Email\n    {\n        public string ToAddress { get; set; }\n        public string Subject { get; set; }\n        public string Content { get; set; }\n        public void SendEmail()\n        {\n            //Send email\n        }\n    }\n\n    public class SMS\n    {\n        public string PhoneNumber { get; set; }\n        public string Message { get; set; }\n        public void SendSMS()\n        {\n            //Send sms\n        }\n    }\n    \n    public class Mail\n    {\n        public string Address { get; set; }\n        public string Message { get; set; }\n        public void SendMail()\n        {\n            //Send Mail by post\n        }\n    }\n    \n    public class Notification\n    {\n        private Email _email;\n        private SMS _sms;\n        private Mail _mail;\n        public Notification()\n        {\n            _email = new Email();\n            _sms = new SMS();\n            _mail = new Mail();\n        }\n\n        public void Send()\n        {\n            _email.SendEmail();\n            _sms.SendSMS();\n            _mail.SendMail();\n        }\n    }\n</code></pre>    \n<p>As we can see from the code sample above, the higher-level (Notification) module has dependencies on Email, SMS, and Mail modules, which are lower-level modules which violate DIP, and the also violates Single Responsibility Principle.</p>\n<h4 id=\"solution\">Solution:</h4>\n<pre><code>\n    public interface IMessage\n    {\n        void SendMessage();\n    }\n    \n    public class Email : IMessage\n    {\n        public string ToAddress { get; set; }\n        public string Subject { get; set; }\n        public string Content { get; set; }\n        public void SendMessage()\n        {\n            //Send Email\n        }\n    }\n\n    public class SMS : IMessage\n    {\n        public string PhoneNumber { get; set; }\n        public string Message { get; set; }\n        public void SendMessage()\n        {\n            //Send SMS\n        }\n    }\n    \n    public class Mail : IMessage\n    {\n        public string Address { get; set; }\n        public string Message { get; set; }\n        public void SendMessage()\n        {\n            //Send Mail by post\n        }\n    }\n</code></pre>  \n<p>The Notification system can now do one thing and one thing only. Send message without bothering about the implementation details, but depend on abstraction.</p>\n<pre><code>\n    public class Notification\n    {\n        private ICollection<IMessage> _messages;\n\n        public Notification(ICollection<IMessage> messages)\n        {\n            this._messages = messages;\n        }\n        public void SendMessage()\n        {\n            foreach(var message in _messages)\n            {\n                message.SendMessage();\n            }\n        }\n    }\n</code></pre> \n<p>This concludes <strong>SOLID</strong> principles. Hope you've learned something today. Happy Coding!</p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5ad74e522f7aa01770eb2e4b",
    "plaintext": "In this post, I try to leave out the intricacies of the SOLID principle and\nwrite about it succinctly in detail, but yet simple codes samples. Let’s get\nstarted\n\nThe SOLID principle is a design pattern that enables and disciplines us to write\nreusable, decoupled, and maintainable code. That is as simple as it can get.\n\nNow, we know what the SOLID principles want to get out of us, let’s briefly talk\nabout what makes a code SOLID. SOLID codes have to satisfy SOLID principle\nchecklist which leads us to the SOLID acronym and what it means.\n\n * S: Single Responsible Principle (SRP)\n * O: Open Closed Principle (OSP)\n * L: Liskov Substituion Principle\n * I: Interface Segregation Principle (ISP)\n * D: Dependency Inversion Principle (DIP)\n\nLet’s go throw each with code walkthrough\n\nS: Single Responsible Principle (SRP)\n> A class should have only one reason to change\n\n\n\n\nSRP says that a class should focus on one specific thing rather than do multiple\nthings. The SRP simple does not mean a class should have only one method, but\neverything the class does should revolve around one thing.\nFor example, a Person class might have the responsibility of carrying out a\nvarious operation such as creating a new person’s record, update, delete, and\nretrieve from a data store. The class can also be tasked on how to present\ninformation to a user such as print, display, sending email, logging etc.\n\nMixing up responsibility makes a class unmaintainable, challenging to understand\nand makes writing unit tests a nightmare because the responsibilities cannot be\nseparated and thus ultimately violates SRP.\n\n\n\nLet’s see an example of SRP violation:\n\n\n    public class Person\n    {\n        public Guid PersonId { get; set; }\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        private decimal Salary { get; set; }\n\n        private string Mydocpath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\n\n        public string FullName()\n        {\n            return $\"{FirstName} - {LastName}\";\n        }\n\n        public decimal GetSalary()\n        {\n            return this.Salary;\n        }\n\n        public void IncreaseSalary(decimal percentage)\n        {\n            this.Salary += this.Salary * percentage;\n        }\n\n        public void SavePerson()\n        {\n            try\n            {\n                // code for saving person to a data store\n\n                //After a person has been saved, we send confirmation email\n                var mailMessage = new MailMessage(\"MailFrom\", \"MailTo\", \"Subject\", \"Body\");\n                this.SendEmail(mailMessage);\n\n            }\n            catch (Exception e)\n            {\n                System.IO.File.WriteAllText(this.Mydocpath + @\"\\Exceptionsfile.txt\", e.ToString());\n            }\n        }\n\n        public void SendEmail(MailMessage mail)\n        {\n            try\n            {\n                // Code for getting Email setting and send mail\n            }\n            catch (Exception e)\n            {\n                System.IO.File.WriteAllText(this.Mydocpath + @\"\\Exceptionsfile.txt\", e.ToString());\n            }\n        }\n\n    }\n\n\nThe Person class violates SRP, as it behaves like a God Object. A God Object is\na class which does everything. An example of a God Object is this:\n\n\n\nThe Swiss army knife in the pictures does so much than just being a pocket tool.\nIt can also store your files .\n\nBack to the Person class which carries out own responsibilities such as get full\nname, get a salary, increase salary and also sending emails and logging as well.\n\nThe \"A class should have only one reason to change\" will not be met if for\nexample, you want to modify the email, logging functionalities or perhaps\nwriting a unit test to test each feature.\n\nSolution:\nLet's refactor the code to satisfy SRP\n\n\n    public class Person\n    {\n        public Guid PersonId { get; set; }\n        public string FirstName { get; set; }\n        public string LastName { get; set; }\n        private decimal Salary { get; set; }\n\n        private FileLogger fileLogger;\n        private MailSender mailSender;\n\n\n        public Person()\n        {\n            fileLogger = new FileLogger();\n            mailSender = new MailSender();\n        }\n\n        public string FullName()\n        {\n            return $\"{FirstName} - {LastName}\";\n        }\n\n        public decimal GetSalary()\n        {\n            return this.Salary;\n        }\n\n        public void IncreaseSalary(decimal percentage)\n        {\n            this.Salary += this.Salary * percentage;\n        }\n\n        public void SavePerson()\n        {\n            try\n            {\n                // code for saving person to a data store\n\n                //After a person has been saved, we send confirmation email\n                //Abstracting away how email is being sent\n                fileLogger.Info(\"Add method Start\");\n                // Code for adding invoice\n                // Once Invoice has been added , send mail \n                mailSender.From = \"contact@gmail.com\";\n                mailSender.To = \"recipient@google.com\";\n                mailSender.Subject = \"Verification\";\n                mailSender.Body = \"This is an email message for Bob and Alice\";\n                mailSender.SendEmail();\n            }\n            catch (Exception e)\n            {\n                fileLogger.Error(\"Exception message\", e);\n            }\n        }\n\n    }\n\n\n\n\n    public interface ILogger\n    {\n        void Info(string info);\n        void Debug(string info);\n        void Error(string info, Exception e);\n    }\n\n    public class FileLogger : ILogger\n    {\n        private string MyDocpath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\n\n        public FileLogger()\n        {\n            //Initialization code(s)\n        }\n\n        public void Info(string info)\n        {\n            // Code for details to text file \n        }\n\n        public void Debug(string info)\n        {\n            // Code for debug information to text file \n        }\n\n        public void Error(string message, Exception ex)\n        {\n            // Code for erros with message and exception details\n        }\n    }\n\n\n    public class MailSender\n    {\n        public string From { get; set; }\n        public string To { get; set; }\n        public string Subject { get; set; }\n        public string Body { get; set; }\n\n        public void SendEmail()\n        {\n            // Code for sending mail\n        }\n    }\n\n\nNow the Person class can focus on what it knows how to do best, and that is how\nto create, save, calculate salary about a user and cares less about sending\nemails or logging hence satisfies the Single Responsibility Princciple. The\nother tasks of logging and email sending are delegated to the responsible\nclasses separating the concerns and responsibilities.\n\n\n\nO: Open Closed Principle (OSP)\n> Software entities (classes, modules, functions, etc) should be open for\nextension , but closed for modification.\n\n\n\n\nTo put it in a simple sentence, change a class behaviour using inheritance and\ncomposition.\n\n\"Open for extension\" means we ought to design our classes in a way that will\nallow new feature or functionality to be added when new requirements arise or a\nchange of request comes up. \"Closed for modification means\" we should not alter\ncodes that have already gone through design, coding, unit testing and it is\nin-production unless it is a bug.\n\nLet's demonstrate OSP using codes using a Shape class.\n\nOSP violation:\n\n\n    public enum ShapeType\n    {\n        Triangle, Rectangle, Circle\n    }\n\n    public class Shape\n    {\n        public ShapeType ShapeType { get; set; }\n        public double Width { get; set; }\n        public double Height { get; set; }\n\n        public string CalculateArea( )\n        {\n            var calculatedArea = default(double);\n\n            if (ShapeType == ShapeType.Triangle)\n            {\n                calculatedArea =  Height * Width;\n            }else if (ShapeType == ShapeType.Triangle)\n            {\n                calculatedArea = 0.5 * Width * Height;\n            }\n            else if(ShapeType == ShapeType.Circle)\n            {\n                calculatedArea = Math.PI * Math.Pow(Height, 2);\n            }\n\n            return calculatedArea.ToString(CultureInfo.InvariantCulture);\n        }\n    }\n\n\nNow, this simple Shape class represents a shape and calculates its area. This\nscenario will work well without issues only if we have to calculate only three\nshapes, Triangle, Rectangle Circle. What if we need to calculate the area of a\nsphere tomorrow or a rhombus? We will have to alter the Shape class and add one\nor more if condition to satisfy the requirement and equally alter the enum to\nadd the new type of shape. Adding more if conditions to cater to new shapes will\nquickly run out of hands and make the code unmaintainable and difficult to test.\nHence, the class is not \"closed for modification\".\n\n\n\nLet's make the Shape class \"Open for extension, but closed for modification\"\nhence satisfying OSP.\n\nOSP solution:\n\n    public abstract class Shape\n    {\n        public abstract double CalculateArea();\n    }\n\n\n    public class Triangle : Shape\n    {\n        public double Base { get; set; }\n        public double Height { get; set; }\n\n        public override double CalculateArea()\n        {\n            return 0.5 * Base * Height;\n        }\n    }\n\n\n    public class Cirle : Shape\n    {\n        public double Radius { get; set; }\n        public override double CalculateArea()\n        {\n            return Math.PI * (Radius * Radius);\n        }\n    }\n\n\nNow that looks much better. The Shape class is now closed for modification\nbecause to add a new feature of calculating a new shape, we don't alter or\nmodify the Shape class. Instead, we extended it by using inheritance.\n\nExtending the Shape class further by adding the rhombus shape will look like\nthis:\n\n\n    public class Rhombus : Shape\n    {\n        public double Diagonal { get; set; }\n        public override double CalculateArea()\n        {\n            return (1/2) * Diagonal * Diagonal;\n        }\n    }\n\n\nViola! we have satisfied OSP.\n\n\n\n\n\nL: Liskov Substitution Principle (LSP)\n> Objects in a program should be replacable with instances of their subtypes\nwithout altering the correctness of the that program.\n\n\n\n\nIn a simple translation, a child class can replace a parent class in a code, and\nit should not break that code. e.g. If class Dog is a child(derived class) of\nclass Animal(base class), then instances of Dog can replace the instance of\nAnimal without issue. Liskov substitution principle goes a bit deeper, but for a\nsimple explanation is a good starting position.\n\nNote: LSP is about honoring contracts and not intending to change the behaviour\nof a base class.\n\nThe code below violates LSP in that derived class Square changed the behaviour\nof the base class.\n\nViolation of LSP:\n\n\n    public class Rectangle\n    {\n        public virtual Int32 Height { get; set; }\n        public virtual Int32 Width { get; set; }\n\n        public virtual void CalculateArea()\n        {\n            Console.WriteLine($\"The area is: {Height * Width}\");\n        }\n    }\n\n    public class Square : Rectangle\n    {\n        public override Int32 Height\n        {\n            get => base.Height;\n            set => SetDimensions(value);\n        }\n\n        public override Int32 Width\n        {\n            get => base.Width;\n            set => SetDimensions(value);\n        }\n\n        private void SetDimensions(Int32 value)\n        {\n            base.Height = value;\n            base.Width = value;\n        }\n    }\n\n\nGiving the above code, a quick run, the output says The area is 9, which is\ncorrect as the area of a square is (width)2. But! this violates the LSP that\nstates that a derived class should replace a base class without breaking or\naltering the program.\n\n\n    static void Main(string[] args)\n    {\n        Rectangle rectangle = new Square();\n        rectangle.Height = 2;\n        rectangle.Width = 3;\n\n        rectangle.CalculateArea(); // The area is 9\n        Console.ReadKey();\n    }\n\n\nLet implement the code to become LSP compliant. The solution to this problem is\nnot straightforward, but let have a look. Remember the OCP, if a code is OCP\ncomplaint, that code is more likely to be LSP compliant as well. As a rule of\nthumb, try to move implementation that may differ to the derived classes and\nleave the more general implementation to the base class.\n\n\n    public interface IShape\n    {\n        void CalculateArea();\n    }\n\n    public class Square : IShape\n    {\n        public double Width { get; set; }\n        public void CalculateArea()\n        {\n            Console.WriteLine($\"The area is {Math.Pow(Width, 2)}\");\n        }\n    }\n\n    public class Rhombus : IShape\n    {\n        public double Diagonal { get; set; }\n        public void CalculateArea()\n        {\n            Console.WriteLine($\"The area is: {(1 / 2) * Diagonal * Diagonal}\");\n        }\n    }\n\n\nThe base class IShape contract is now implemented by Square and Rhombus with no\nviolation by not allowing the subclasses to change the behaviour of the base\nclass.\n\nImportant: If a code is OSP complaint, it is likely, it is LSP complaint as both\ngo hand in hand.\n\n\n\n\n\nI: Interface Segregation Principle (ISP)\n> No client should be forced to depend on methods it does not need. Split large\ninterfaces into smaller and more specific ones so clients can pick and choose\nmethods that are of interest to them.\n\n\n\n\nIn a simple sentence, this means a derived class should only implement what it\nneeds and not all methods in the parent class or interface.\n\nUsing the analogy of a manager, a lead developer, and a developer.\n\nViolation of ISP:\n\n\n    public interface ILead\n    {\n        void CreateSubTask();\n        void AssginTask();\n        void WorkOnTask();\n    }\n\n    public class Developer : ILead\n    {\n        public void CreateSubTask()\n        {\n            throw new Exception(\"Cannot create subtasks\");\n        }\n\n        public void AssginTask()\n        {\n            throw new Exception(\"Cannot assign tasks\");\n        }\n\n        public void WorkOnTask()\n        {\n            //codes to implement working on tasks\n        }\n    }\n\n    public class LeadDeveloper : ILead\n    {\n        public void CreateSubTask()\n        {\n            //code to create subtasks\n        }\n\n        public void AssginTask()\n        {\n            //code to assign tasks\n        }\n\n        public void WorkOnTask()\n        {\n            //codes to implement working on tasks\n        }\n    }\n\n    public class Manager : ILead\n    {\n        public void CreateSubTask()\n        {\n            //code to create subtasks\n        }\n\n        public void AssginTask()\n        {\n            //code to assign tasks\n        }\n\n        public void WorkOnTask()\n        {\n            throw new Exception(\"Manager cannot work on programming tasks\");\n        }\n    }\n\n\nWe have three roles in that a Manager cannot work on tasks and no can assign a\ntask to a manger aside from the manager's boss if there's another layer of\nhierarchy. But the Manager implements the WorkOnTask() method it doesn't need.\nSame for the Developer class, a developer cannot create subtasks and assign\ntasks hence should not be implementing both methods. As for the LeadDeveloper,\nit implements all method on the ILead interface as needed.\n\nSolution:\nThe solution is to split the interfaces into manageable chunks to clients can\npick and choose what they need to implement.\n\n\n    public interface ILead\n    {\n        void CreateSubTask();\n        void AssginTask();\n    }\n\n    public interface IProgrammer\n    {\n        void WorkOnTask();\n    }\n\n    public class Developer : IProgrammer\n    {\n        public void WorkOnTask()\n        {\n            //codes to implement working on tasks\n        }\n    }\n\n    public class LeadDeveloper : ILead, IProgrammer\n    {\n        public void CreateSubTask()\n        {\n            //code to create subtasks\n        }\n\n        public void AssginTask()\n        {\n            //code to assign tasks\n        }\n\n        public void WorkOnTask()\n        {\n            //codes to implement working on tasks\n        }\n    }\n\n    public class Manager : ILead\n    {\n        public void CreateSubTask()\n        {\n            //code to create subtasks\n        }\n\n        public void AssginTask()\n        {\n            //code to assign tasks\n        }\n    }\n\n\n\n\n\n\nD: Dependency Inversion Principle (DIP)\n> High level modules should not depend on low level modules, Both should depend on\nabstractions. Abstractions should not depend on details. Details should depend\non abstractions\n\n\n\n\nIn a simple sentence, high-level modules and low-level module should be loosely\ncoupled as much as possible. They need not know the detail implementation of\neach other, in other words, they should depend on a contract.\n\nLet's use the example of a notification system where we can either send Email,\nSMS or Mail depending on a user choosing. Alternatively, all three if the user\nopt-in for all.\n\nViolation of DIP:\n\n    public class Email\n    {\n        public string ToAddress { get; set; }\n        public string Subject { get; set; }\n        public string Content { get; set; }\n        public void SendEmail()\n        {\n            //Send email\n        }\n    }\n\n    public class SMS\n    {\n        public string PhoneNumber { get; set; }\n        public string Message { get; set; }\n        public void SendSMS()\n        {\n            //Send sms\n        }\n    }\n    \n    public class Mail\n    {\n        public string Address { get; set; }\n        public string Message { get; set; }\n        public void SendMail()\n        {\n            //Send Mail by post\n        }\n    }\n    \n    public class Notification\n    {\n        private Email _email;\n        private SMS _sms;\n        private Mail _mail;\n        public Notification()\n        {\n            _email = new Email();\n            _sms = new SMS();\n            _mail = new Mail();\n        }\n\n        public void Send()\n        {\n            _email.SendEmail();\n            _sms.SendSMS();\n            _mail.SendMail();\n        }\n    }\n\n\nAs we can see from the code sample above, the higher-level (Notification) module\nhas dependencies on Email, SMS, and Mail modules, which are lower-level modules\nwhich violate DIP, and the also violates Single Responsibility Principle.\n\nSolution:\n\n    public interface IMessage\n    {\n        void SendMessage();\n    }\n    \n    public class Email : IMessage\n    {\n        public string ToAddress { get; set; }\n        public string Subject { get; set; }\n        public string Content { get; set; }\n        public void SendMessage()\n        {\n            //Send Email\n        }\n    }\n\n    public class SMS : IMessage\n    {\n        public string PhoneNumber { get; set; }\n        public string Message { get; set; }\n        public void SendMessage()\n        {\n            //Send SMS\n        }\n    }\n    \n    public class Mail : IMessage\n    {\n        public string Address { get; set; }\n        public string Message { get; set; }\n        public void SendMessage()\n        {\n            //Send Mail by post\n        }\n    }\n\n\nThe Notification system can now do one thing and one thing only. Send message\nwithout bothering about the implementation details, but depend on abstraction.\n\n\n    public class Notification\n    {\n        private ICollection _messages;\n\n        public Notification(ICollection messages)\n        {\n            this._messages = messages;\n        }\n        public void SendMessage()\n        {\n            foreach(var message in _messages)\n            {\n                message.SendMessage();\n            }\n        }\n    }\n\n\nThis concludes SOLID principles. Hope you've learned something today. Happy\nCoding!",
    "feature_image": null,
    "featured": 1,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-18 13:55:30",
    "updated_at": "2019-06-30 18:58:59",
    "published_at": "2018-04-22 05:48:20",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7e4",
    "uuid": "aa5471e2-8924-43ba-9e4d-0f4b92719dbb",
    "title": "contact",
    "slug": "contact",
    "mobiledoc": "{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"<p>If you are interested in contacting me for any reason, do not hesitate to use any of the medium below:</p>\\n\\n<p><i class=\\\"fas fa-envelope\\\"></i> <a href=\\\"mailto:michael@codesrealm.com\\\">michael@codesrealm.com</a></p>\\n<p><i class=\\\"fab fa-linkedin\\\"></i> <a href=\\\"https://www.linkedin.com/in/mcvavy/\\\" target=\\\"_blank\\\">https://www.linkedin.com/in/mcvavy/</a></p>\\n<p><i class=\\\"fab fa-github\\\"></i> <a href=\\\"https://github.com/mcvavy\\\" target=\\\"_blank\\\">https://github.com/mcvavy</a></p>\\n\\n\"}]],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>If you are interested in contacting me for any reason, do not hesitate to use any of the medium below:</p>\n<p><i class=\"fas fa-envelope\"></i> <a href=\"mailto:michael@codesrealm.com\">michael@codesrealm.com</a></p>\n<p><i class=\"fab fa-linkedin\"></i> <a href=\"https://www.linkedin.com/in/mcvavy/\" target=\"_blank\">https://www.linkedin.com/in/mcvavy/</a></p>\n<p><i class=\"fab fa-github\"></i> <a href=\"https://github.com/mcvavy\" target=\"_blank\">https://github.com/mcvavy</a></p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5adc1251b660db1f20cd5739",
    "plaintext": "If you are interested in contacting me for any reason, do not hesitate to use\nany of the medium below:\n\n michael@codesrealm.com\n\n https://www.linkedin.com/in/mcvavy/\n\n https://github.com/mcvavy",
    "feature_image": null,
    "featured": 0,
    "type": "page",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-22 04:40:49",
    "updated_at": "2018-04-22 04:59:01",
    "published_at": "2018-04-22 04:41:04",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7e5",
    "uuid": "304986ec-cf99-4075-b899-6f62e44228d4",
    "title": "About",
    "slug": "about",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"#Who am I?\\n<p>I refer to myself as a programming and technology enthusiast, a craftsman, & an adventure seeker.</p>\\n<p>I am in love with programming, software engineering, and web technologies. I love to see results come to life out of nothing and idead and that, make feel like a god. I speak only for my self <i class=\\\"far fa-smile\\\"></i></p>\\n\\n#About this blog\\nThis blog is solely for sharing my opinion and not that of others such as my colleagues and my employer.\\n\\nI try to share my experience, thoughts, knowledge, things I've learned, software engineering best practices, open-source & Microsoft technology.\\n\"}]],\"markups\":[],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><h1 id=\"whoami\">Who am I?</h1>\n<p>I refer to myself as a programming and technology enthusiast, a craftsman, & an adventure seeker.</p>\n<p>I am in love with programming, software engineering, and web technologies. I love to see results come to life out of nothing and idead and that, make feel like a god. I speak only for my self <i class=\"far fa-smile\"></i></p>\n<h1 id=\"aboutthisblog\">About this blog</h1>\n<p>This blog is solely for sharing my opinion and not that of others such as my colleagues and my employer.</p>\n<p>I try to share my experience, thoughts, knowledge, things I've learned, software engineering best practices, open-source &amp; Microsoft technology.</p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5adc127ab660db1f20cd573b",
    "plaintext": "Who am I?\nI refer to myself as a programming and technology enthusiast, a craftsman, & an\nadventure seeker.\n\nI am in love with programming, software engineering, and web technologies. I\nlove to see results come to life out of nothing and idead and that, make feel\nlike a god. I speak only for my self \n\nAbout this blog\nThis blog is solely for sharing my opinion and not that of others such as my\ncolleagues and my employer.\n\nI try to share my experience, thoughts, knowledge, things I've learned, software\nengineering best practices, open-source & Microsoft technology.",
    "feature_image": null,
    "featured": 0,
    "type": "page",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-22 04:41:30",
    "updated_at": "2019-07-02 16:00:26",
    "published_at": "2018-04-22 04:41:41",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7e6",
    "uuid": "25244a02-a145-4e44-8c44-00c4679073b2",
    "title": "Pillars of Objected-Oriented Programming",
    "slug": "pillars-of-objected-oriented-programming",
    "mobiledoc": "{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:  \\n\\nThis series is as follows:\\n\\n1.  [Pillars of Objected-Oriented Programming](/pillars-of-objected-oriented-programming)\\n2. [JavaScript Objects, prototype, constructor, & Object constructor](/javascript-objects-prototype-constructor/)\\n3. [Object Creation in JavaScript](/object-creation-in-javascript/)\\n4. [JavaScript OOP : Abstraction](/pillars-of-object-oriented-programming-abstraction-2/)\\n5. [JavaScript OOP : Encapsulation](/pillars-of-object-oriented-programming-encapsulation/)\\n6. [JavaScript OOP : Inheritance](/pillars-of-object-oriented-programming-inheritance)\\n7. [JavaScript OOP : Polymorphism](/pillars-of-object-oriented-programming-polymorphism)\\n8. [JavaScript OOP : Inheritance vs Composition]()\\n\\n\\nObject-oriented programming has four pillars which we will quickly go over. These pillars or concept define or set some guidelines on how to write codes to represent objects with characteristics and behaviours. E.g., A person may be described as an object with attributes like first name, last name, date of Birth and a person can eat, walk, run, and dance.\\n\\nThe four pillars are namely,  __Abstraction__, __Encapsulation__, __Inheritance__, and __Polymorphism__.  \\n\\n### Abstraction\\nAn abstraction in object-oriented programming (OOP) is the process of hiding away the complexity of an object's internal implementation details and present relevant information without noise. An example of abstraction in the real world is a simple cassette player\\n\\n![Casset player](https://images.unsplash.com/photo-1495369470453-f6af4ade471b?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=1b9c2148b9404faac82511c12524ffe7&auto=format&fit=crop&w=1350&q=80)\\n\\nThis cassette player has few buttons on it, but the implementation details of how the electronics embedded inside work are abstracted away, it's hidden, and all that's useful to a music listener is the play, pause, forward, rewind and record buttons. The details of how the capacitors, diode , resistors, circuit board work is of no importance and as a music listener, I don't know want know either.\\n\\n### Encapsulation\\nIn a simple sentence, encapsulation is the process of hiding internal details or implementation from the outside such that it helps prevent tampering and accidental modification. As you programming more and create objects, you will quickly realise some details should never leak as a result of our code which could lead to serious problems like data breach, losing sensitive data and confidentiality. Different programming languages use different implementation to achieve encapsulation. In the coming post, we will see how we can implement encapsulation in JavaScript which is a bit different from strongly typed languages like C# and Java.   \\n\\n### Inheritance\\nInheritance in OOP is just like inheritance in real life whereby a child inherits the parent(s) trait(s) such as eye colours, height etc.  Inheritance describes an \\\"IS-A\\\" relationship e.g. a dog is an Animal etc. Inheritance in OOP helps reduce code duplication by re-using codes or sharing codes. E.g. You are writing an application for a vet. You have to ensure that your application can handle check-in and check-out of all kinds of animal. The only way to make this possible is by re-using code. In this case, you will have a base object called Animal with general characteristics animal characteristics and have, e.g. dogs; cat inherits from the Animal class. In conclusion, inheritance is the ability of a child object to inherit a parent object properties and behaviours in addition to its own.\\n\\n### Polymorphism\\n*Poly* means many, and *morphism* means forms. Polymorphism is the ability of an object to exist or represented in many forms. In OOP, child or children object may inherit behaviour from a parent object and override or implement that object differently from the parent.  In conclusion, *polymorphism* is the ability of an object to change behaviour at runtime.  \\n\\n### Composition\\nComposition is an important OOP concept worth mentioning. It's not one of the four listed pillars of OOP, but OOP is not complete without it. Unlike inheritance, composition is a *\\\"HAS-A\\\"* relationship. A dog is an animal, but a dog has an owner. An object representing a dog will relate to the animal object by inheritance, but relate to owner through composition.\\n\\nThis concludes the information needed to delve into the concepts of OOP deeper.\\n\\n\\n\\n\"}]],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:</p>\n<p>This series is as follows:</p>\n<ol>\n<li><a href=\"/pillars-of-objected-oriented-programming\">Pillars of Objected-Oriented Programming</a></li>\n<li><a href=\"/javascript-objects-prototype-constructor/\">JavaScript Objects, prototype, constructor, &amp; Object constructor</a></li>\n<li><a href=\"/object-creation-in-javascript/\">Object Creation in JavaScript</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-abstraction-2/\">JavaScript OOP : Abstraction</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-encapsulation/\">JavaScript OOP : Encapsulation</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-inheritance\">JavaScript OOP : Inheritance</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-polymorphism\">JavaScript OOP : Polymorphism</a></li>\n<li><a href=\"\">JavaScript OOP : Inheritance vs Composition</a></li>\n</ol>\n<p>Object-oriented programming has four pillars which we will quickly go over. These pillars or concept define or set some guidelines on how to write codes to represent objects with characteristics and behaviours. E.g., A person may be described as an object with attributes like first name, last name, date of Birth and a person can eat, walk, run, and dance.</p>\n<p>The four pillars are namely,  <strong>Abstraction</strong>, <strong>Encapsulation</strong>, <strong>Inheritance</strong>, and <strong>Polymorphism</strong>.</p>\n<h3 id=\"abstraction\">Abstraction</h3>\n<p>An abstraction in object-oriented programming (OOP) is the process of hiding away the complexity of an object's internal implementation details and present relevant information without noise. An example of abstraction in the real world is a simple cassette player</p>\n<p><img src=\"https://images.unsplash.com/photo-1495369470453-f6af4ade471b?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=1b9c2148b9404faac82511c12524ffe7&amp;auto=format&amp;fit=crop&amp;w=1350&amp;q=80\" alt=\"Casset player\"></p>\n<p>This cassette player has few buttons on it, but the implementation details of how the electronics embedded inside work are abstracted away, it's hidden, and all that's useful to a music listener is the play, pause, forward, rewind and record buttons. The details of how the capacitors, diode , resistors, circuit board work is of no importance and as a music listener, I don't know want know either.</p>\n<h3 id=\"encapsulation\">Encapsulation</h3>\n<p>In a simple sentence, encapsulation is the process of hiding internal details or implementation from the outside such that it helps prevent tampering and accidental modification. As you programming more and create objects, you will quickly realise some details should never leak as a result of our code which could lead to serious problems like data breach, losing sensitive data and confidentiality. Different programming languages use different implementation to achieve encapsulation. In the coming post, we will see how we can implement encapsulation in JavaScript which is a bit different from strongly typed languages like C# and Java.</p>\n<h3 id=\"inheritance\">Inheritance</h3>\n<p>Inheritance in OOP is just like inheritance in real life whereby a child inherits the parent(s) trait(s) such as eye colours, height etc.  Inheritance describes an &quot;IS-A&quot; relationship e.g. a dog is an Animal etc. Inheritance in OOP helps reduce code duplication by re-using codes or sharing codes. E.g. You are writing an application for a vet. You have to ensure that your application can handle check-in and check-out of all kinds of animal. The only way to make this possible is by re-using code. In this case, you will have a base object called Animal with general characteristics animal characteristics and have, e.g. dogs; cat inherits from the Animal class. In conclusion, inheritance is the ability of a child object to inherit a parent object properties and behaviours in addition to its own.</p>\n<h3 id=\"polymorphism\">Polymorphism</h3>\n<p><em>Poly</em> means many, and <em>morphism</em> means forms. Polymorphism is the ability of an object to exist or represented in many forms. In OOP, child or children object may inherit behaviour from a parent object and override or implement that object differently from the parent.  In conclusion, <em>polymorphism</em> is the ability of an object to change behaviour at runtime.</p>\n<h3 id=\"composition\">Composition</h3>\n<p>Composition is an important OOP concept worth mentioning. It's not one of the four listed pillars of OOP, but OOP is not complete without it. Unlike inheritance, composition is a <em>&quot;HAS-A&quot;</em> relationship. A dog is an animal, but a dog has an owner. An object representing a dog will relate to the animal object by inheritance, but relate to owner through composition.</p>\n<p>This concludes the information needed to delve into the concepts of OOP deeper.</p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5ae569bad8240f1f647a63c0",
    "plaintext": "This post is part of a series of posts on JavaScript object-oriented\nprogramming. Link to the series are as follows:\n\nThis series is as follows:\n\n 1. Pillars of Objected-Oriented Programming\n    [/pillars-of-objected-oriented-programming]\n 2. JavaScript Objects, prototype, constructor, & Object constructor\n    [/javascript-objects-prototype-constructor/]\n 3. Object Creation in JavaScript [/object-creation-in-javascript/]\n 4. JavaScript OOP : Abstraction\n    [/pillars-of-object-oriented-programming-abstraction-2/]\n 5. JavaScript OOP : Encapsulation\n    [/pillars-of-object-oriented-programming-encapsulation/]\n 6. JavaScript OOP : Inheritance\n    [/pillars-of-object-oriented-programming-inheritance]\n 7. JavaScript OOP : Polymorphism\n    [/pillars-of-object-oriented-programming-polymorphism]\n 8. JavaScript OOP : Inheritance vs Composition\n\nObject-oriented programming has four pillars which we will quickly go over.\nThese pillars or concept define or set some guidelines on how to write codes to\nrepresent objects with characteristics and behaviours. E.g., A person may be\ndescribed as an object with attributes like first name, last name, date of Birth\nand a person can eat, walk, run, and dance.\n\nThe four pillars are namely, Abstraction, Encapsulation, Inheritance, and \nPolymorphism.\n\nAbstraction\nAn abstraction in object-oriented programming (OOP) is the process of hiding\naway the complexity of an object's internal implementation details and present\nrelevant information without noise. An example of abstraction in the real world\nis a simple cassette player\n\n\n\nThis cassette player has few buttons on it, but the implementation details of\nhow the electronics embedded inside work are abstracted away, it's hidden, and\nall that's useful to a music listener is the play, pause, forward, rewind and\nrecord buttons. The details of how the capacitors, diode , resistors, circuit\nboard work is of no importance and as a music listener, I don't know want know\neither.\n\nEncapsulation\nIn a simple sentence, encapsulation is the process of hiding internal details or\nimplementation from the outside such that it helps prevent tampering and\naccidental modification. As you programming more and create objects, you will\nquickly realise some details should never leak as a result of our code which\ncould lead to serious problems like data breach, losing sensitive data and\nconfidentiality. Different programming languages use different implementation to\nachieve encapsulation. In the coming post, we will see how we can implement\nencapsulation in JavaScript which is a bit different from strongly typed\nlanguages like C# and Java.\n\nInheritance\nInheritance in OOP is just like inheritance in real life whereby a child\ninherits the parent(s) trait(s) such as eye colours, height etc. Inheritance\ndescribes an \"IS-A\" relationship e.g. a dog is an Animal etc. Inheritance in OOP\nhelps reduce code duplication by re-using codes or sharing codes. E.g. You are\nwriting an application for a vet. You have to ensure that your application can\nhandle check-in and check-out of all kinds of animal. The only way to make this\npossible is by re-using code. In this case, you will have a base object called\nAnimal with general characteristics animal characteristics and have, e.g. dogs;\ncat inherits from the Animal class. In conclusion, inheritance is the ability of\na child object to inherit a parent object properties and behaviours in addition\nto its own.\n\nPolymorphism\nPoly means many, and morphism means forms. Polymorphism is the ability of an\nobject to exist or represented in many forms. In OOP, child or children object\nmay inherit behaviour from a parent object and override or implement that object\ndifferently from the parent. In conclusion, polymorphism is the ability of an\nobject to change behaviour at runtime.\n\nComposition\nComposition is an important OOP concept worth mentioning. It's not one of the\nfour listed pillars of OOP, but OOP is not complete without it. Unlike\ninheritance, composition is a \"HAS-A\" relationship. A dog is an animal, but a\ndog has an owner. An object representing a dog will relate to the animal object\nby inheritance, but relate to owner through composition.\n\nThis concludes the information needed to delve into the concepts of OOP deeper.",
    "feature_image": "https://images.unsplash.com/photo-1523500979934-bdf0933261d2?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=2dfea8d7ccac5dc4419f4c2bd9df972d",
    "featured": 0,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-29 06:44:10",
    "updated_at": "2018-07-27 02:33:29",
    "published_at": "2018-04-29 14:24:00",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7e7",
    "uuid": "f0ba5175-c4e2-4f5b-bbea-bf3c9b3576bb",
    "title": "JavaScript Objects, prototype, constructor, & Object constructor",
    "slug": "javascript-objects-prototype-constructor",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:  \\n\\nThis series is as follows:\\n\\n1.  [Pillars of Objected-Oriented Programming](/pillars-of-objected-oriented-programming)\\n2. [JavaScript Objects, prototype, constructor, & Object constructor](/javascript-objects-prototype-constructor/)\\n3. [Object Creation in JavaScript](/object-creation-in-javascript/)\\n4. [JavaScript OOP : Abstraction](/pillars-of-object-oriented-programming-abstraction-2/)\\n5. [JavaScript OOP : Encapsulation](/pillars-of-object-oriented-programming-encapsulation/)\\n6. [JavaScript OOP : Inheritance](/pillars-of-object-oriented-programming-inheritance)\\n7. [JavaScript OOP : Polymorphism](/pillars-of-object-oriented-programming-polymorphism)\\n8. [JavaScript OOP : Inheritance vs Composition]()\\n\\n<p class=\\\"space\\\"></p>\\n\\n## __JavaScript Objects__\\nAccording to [Mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects), JavaScript is designed on a simple object-based paradigm, and ==*an object is a collection of properties, and property is an association between a name(or key) and a value. A property's value can be a function, in which case the property is known as a method.*==  \\n\\nIn other words, an object is a collection of key=value pair.\\n\\ne.g      firstname = \\\"John\\\", lastname = \\\"Fischer\\\" .  These two key-value pair can make up an object\\n\\n<p class=\\\"space\\\"></p>\\n\\n#### Objects & properties\\n\\nTo represent a *Person* object in JavaScript, let's use *Object* with is JavaScript in-built. It's the low-level way of creating an object.\\n\\n<pre><code class=\\\"js\\\">\\n    var person = new Object();\\n    person.firstname = \\\"John\\\";\\n    person.lastname = \\\"Fischer\\\"\\n    person.age = 24\\n</code></pre>\\n\\nThe person object has three properties, firstname, lastname, and age. Remember a property's value can also be a function which is refered to as a method. Methods add behaviour to an object. Let's add a behaviour to the person object.\\n\\n<pre><code class=\\\"js\\\">\\n    person.showSkill = function(){\\n         console.log(\\\"I can code in JavaScript\\\")\\n    }\\n</code></pre>\\n\\nIt's possible to add more property to the object because JavaScript is a dynamic language and that's powerful.\\n\\n![object](/content/images/2018/04/object.png)\\n\\n<p class=\\\"space\\\"></p>\\n\\n## __Prototypes__\\n\\nNow, this is the main thing that answers all questions you may have about OOP in JavaScript.\\n\\n<b>What is prototype ?</b>\\nIn simple English, a prototype is a blueprint, first design, a layout etc.   It is what it says.\\n\\nIn almost every invention that has ever existed, they can all be traced to a prototype or a blueprint of some sort.\\n\\n__Note:__ When an object is created in JavaScript, a prototype object is also created and associated with that object.This happens all the time and almost all JavaScript's object prototype is **Object**\\n\\nLet's inspect the person object we created earlier\\n![prototype](https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2FScreenshot%202019-07-07%20at%2020.03.34.png)\\n\\nAlmost every object in JavaScript has prototype pointing to **Object** in JavaScript.  \\n\\nAn object's prototype can be accessed by using the __\\\\_\\\\_proto\\\\_\\\\___ or __prototype__ properties. \\n\\n\\n\\n> The __prototype__ property of an object is used to access an object's prototype in constructor functions, functions that are instantiated using the **new** keyword\\n\\n> __\\\\_\\\\_proto\\\\_\\\\___ property is used to access prototype on object's instance. \\n\\ne.g person.__\\\\_\\\\_proto\\\\_\\\\___ & &lt;constructor function &gt;.prototype. The person object we saw earlier is an example of an instance of an object which is **Object**, we can say person object is an instance of Object. From the person object above, we can clearly see there's no __prototype__ property, but __\\\\_\\\\_proto\\\\_\\\\___ property.\\n\\n<p class=\\\"space\\\"></p>\\n\\n## __constructor__\\n\\nConstructor is found on the prototype object's property; it's a pointer or reference back to an object as the creator. This feature can be dynamically used to create an object dynamically, but that's a more advanced topic.  \\n\\n<p class=\\\"space\\\"></p>\\n\\n## __Object constructor__\\n>_==All objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype==_\\n\\n>_==The Object constructor creates an object wrapper for the given value.==_\\n\\nEvery property available on the Object prototype is also available to all object created in javaScript. Object represents the global JavaScript Object. Object constructor and methods are preffered way of implementing prototypical inherirance and object creation. We will be seeing more of the Object constructor in action in the next series.\\n\\nIn conclusion, almost everything in JavaScript resolves around Object. Understanding how Object works under the hood will pave way to understanding how OOP work in JavaScript. If the concepts of prototype is not very clear. We shall cement that in the next series.\\n\\nHappy coding !\"}]],\"markups\":[],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:</p>\n<p>This series is as follows:</p>\n<ol>\n<li><a href=\"/pillars-of-objected-oriented-programming\">Pillars of Objected-Oriented Programming</a></li>\n<li><a href=\"/javascript-objects-prototype-constructor/\">JavaScript Objects, prototype, constructor, &amp; Object constructor</a></li>\n<li><a href=\"/object-creation-in-javascript/\">Object Creation in JavaScript</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-abstraction-2/\">JavaScript OOP : Abstraction</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-encapsulation/\">JavaScript OOP : Encapsulation</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-inheritance\">JavaScript OOP : Inheritance</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-polymorphism\">JavaScript OOP : Polymorphism</a></li>\n<li><a href=\"\">JavaScript OOP : Inheritance vs Composition</a></li>\n</ol>\n<p class=\"space\"></p>\n<h2 id=\"javascriptobjects\"><strong>JavaScript Objects</strong></h2>\n<p>According to <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects\">Mozilla</a>, JavaScript is designed on a simple object-based paradigm, and <mark><em>an object is a collection of properties, and property is an association between a name(or key) and a value. A property's value can be a function, in which case the property is known as a method.</em></mark></p>\n<p>In other words, an object is a collection of key=value pair.</p>\n<p>e.g      firstname = &quot;John&quot;, lastname = &quot;Fischer&quot; .  These two key-value pair can make up an object</p>\n<p class=\"space\"></p>\n<h4 id=\"objectsproperties\">Objects &amp; properties</h4>\n<p>To represent a <em>Person</em> object in JavaScript, let's use <em>Object</em> with is JavaScript in-built. It's the low-level way of creating an object.</p>\n<pre><code class=\"js\">\n    var person = new Object();\n    person.firstname = \"John\";\n    person.lastname = \"Fischer\"\n    person.age = 24\n</code></pre>\n<p>The person object has three properties, firstname, lastname, and age. Remember a property's value can also be a function which is refered to as a method. Methods add behaviour to an object. Let's add a behaviour to the person object.</p>\n<pre><code class=\"js\">\n    person.showSkill = function(){\n         console.log(\"I can code in JavaScript\")\n    }\n</code></pre>\n<p>It's possible to add more property to the object because JavaScript is a dynamic language and that's powerful.</p>\n<p><img src=\"/content/images/2018/04/object.png\" alt=\"object\"></p>\n<p class=\"space\"></p>\n<h2 id=\"prototypes\"><strong>Prototypes</strong></h2>\n<p>Now, this is the main thing that answers all questions you may have about OOP in JavaScript.</p>\n<p><b>What is prototype ?</b><br>\nIn simple English, a prototype is a blueprint, first design, a layout etc.   It is what it says.</p>\n<p>In almost every invention that has ever existed, they can all be traced to a prototype or a blueprint of some sort.</p>\n<p><strong>Note:</strong> When an object is created in JavaScript, a prototype object is also created and associated with that object.This happens all the time and almost all JavaScript's object prototype is <strong>Object</strong></p>\n<p>Let's inspect the person object we created earlier<br>\n<img src=\"https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2FScreenshot%202019-07-07%20at%2020.03.34.png\" alt=\"prototype\"></p>\n<p>Almost every object in JavaScript has prototype pointing to <strong>Object</strong> in JavaScript.</p>\n<p>An object's prototype can be accessed by using the <strong>__proto__</strong> or <strong>prototype</strong> properties.</p>\n<blockquote>\n<p>The <strong>prototype</strong> property of an object is used to access an object's prototype in constructor functions, functions that are instantiated using the <strong>new</strong> keyword</p>\n</blockquote>\n<blockquote>\n<p><strong>__proto__</strong> property is used to access prototype on object's instance.</p>\n</blockquote>\n<p>e.g person.<strong>__proto__</strong> &amp; &lt;constructor function &gt;.prototype. The person object we saw earlier is an example of an instance of an object which is <strong>Object</strong>, we can say person object is an instance of Object. From the person object above, we can clearly see there's no <strong>prototype</strong> property, but <strong>__proto__</strong> property.</p>\n<p class=\"space\"></p>\n<h2 id=\"constructorfunction Object() { [native code] }1\"><strong>constructor</strong></h2>\n<p>Constructor is found on the prototype object's property; it's a pointer or reference back to an object as the creator. This feature can be dynamically used to create an object dynamically, but that's a more advanced topic.</p>\n<p class=\"space\"></p>\n<h2 id=\"objectconstructor\"><strong>Object constructor</strong></h2>\n<blockquote>\n<p><em><mark>All objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype</mark></em></p>\n</blockquote>\n<blockquote>\n<p><em><mark>The Object constructor creates an object wrapper for the given value.</mark></em></p>\n</blockquote>\n<p>Every property available on the Object prototype is also available to all object created in javaScript. Object represents the global JavaScript Object. Object constructor and methods are preffered way of implementing prototypical inherirance and object creation. We will be seeing more of the Object constructor in action in the next series.</p>\n<p>In conclusion, almost everything in JavaScript resolves around Object. Understanding how Object works under the hood will pave way to understanding how OOP work in JavaScript. If the concepts of prototype is not very clear. We shall cement that in the next series.</p>\n<p>Happy coding !</p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5ae569d0d8240f1f647a63c2",
    "plaintext": "This post is part of a series of posts on JavaScript object-oriented\nprogramming. Link to the series are as follows:\n\nThis series is as follows:\n\n 1. Pillars of Objected-Oriented Programming\n    [/pillars-of-objected-oriented-programming]\n 2. JavaScript Objects, prototype, constructor, & Object constructor\n    [/javascript-objects-prototype-constructor/]\n 3. Object Creation in JavaScript [/object-creation-in-javascript/]\n 4. JavaScript OOP : Abstraction\n    [/pillars-of-object-oriented-programming-abstraction-2/]\n 5. JavaScript OOP : Encapsulation\n    [/pillars-of-object-oriented-programming-encapsulation/]\n 6. JavaScript OOP : Inheritance\n    [/pillars-of-object-oriented-programming-inheritance]\n 7. JavaScript OOP : Polymorphism\n    [/pillars-of-object-oriented-programming-polymorphism]\n 8. JavaScript OOP : Inheritance vs Composition\n\n\n\nJavaScript Objects\nAccording to Mozilla\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects]\n, JavaScript is designed on a simple object-based paradigm, and an object is a\ncollection of properties, and property is an association between a name(or key)\nand a value. A property's value can be a function, in which case the property is\nknown as a method.\n\nIn other words, an object is a collection of key=value pair.\n\ne.g firstname = \"John\", lastname = \"Fischer\" . These two key-value pair can make\nup an object\n\n\n\nObjects & properties\nTo represent a Person object in JavaScript, let's use Object with is JavaScript\nin-built. It's the low-level way of creating an object.\n\n\n    var person = new Object();\n    person.firstname = \"John\";\n    person.lastname = \"Fischer\"\n    person.age = 24\n\n\nThe person object has three properties, firstname, lastname, and age. Remember a\nproperty's value can also be a function which is refered to as a method. Methods\nadd behaviour to an object. Let's add a behaviour to the person object.\n\n\n    person.showSkill = function(){\n         console.log(\"I can code in JavaScript\")\n    }\n\n\nIt's possible to add more property to the object because JavaScript is a dynamic\nlanguage and that's powerful.\n\n\n\n\n\nPrototypes\nNow, this is the main thing that answers all questions you may have about OOP in\nJavaScript.\n\nWhat is prototype ?\nIn simple English, a prototype is a blueprint, first design, a layout etc. It is\nwhat it says.\n\nIn almost every invention that has ever existed, they can all be traced to a\nprototype or a blueprint of some sort.\n\nNote: When an object is created in JavaScript, a prototype object is also\ncreated and associated with that object.This happens all the time and almost all\nJavaScript's object prototype is Object\n\nLet's inspect the person object we created earlier\n\n\nAlmost every object in JavaScript has prototype pointing to Object in\nJavaScript.\n\nAn object's prototype can be accessed by using the __proto__ or prototype \nproperties.\n\n> The prototype property of an object is used to access an object's prototype in\nconstructor functions, functions that are instantiated using the new keyword\n\n\n> __proto__ property is used to access prototype on object's instance.\n\n\ne.g person.__proto__ & <constructor function >.prototype. The person object we\nsaw earlier is an example of an instance of an object which is Object, we can\nsay person object is an instance of Object. From the person object above, we can\nclearly see there's no prototype property, but __proto__ property.\n\n\n\nconstructor\nConstructor is found on the prototype object's property; it's a pointer or\nreference back to an object as the creator. This feature can be dynamically used\nto create an object dynamically, but that's a more advanced topic.\n\n\n\nObject constructor\n> All objects in JavaScript are descended from Object; all objects inherit methods\nand properties from Object.prototype\n\n\n> The Object constructor creates an object wrapper for the given value.\n\n\nEvery property available on the Object prototype is also available to all object\ncreated in javaScript. Object represents the global JavaScript Object. Object\nconstructor and methods are preffered way of implementing prototypical\ninherirance and object creation. We will be seeing more of the Object\nconstructor in action in the next series.\n\nIn conclusion, almost everything in JavaScript resolves around Object.\nUnderstanding how Object works under the hood will pave way to understanding how\nOOP work in JavaScript. If the concepts of prototype is not very clear. We shall\ncement that in the next series.\n\nHappy coding !",
    "feature_image": null,
    "featured": 0,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-29 06:44:32",
    "updated_at": "2019-07-07 19:04:42",
    "published_at": "2018-05-01 12:30:00",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7e8",
    "uuid": "a3b3372b-076b-4166-a10c-925d6ec19949",
    "title": "Object Creation in JavaScript",
    "slug": "object-creation-in-javascript",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:  \\n\\nThis series is as follows:\\n\\n1.  [Pillars of Objected-Oriented Programming](/pillars-of-objected-oriented-programming)\\n2. [JavaScript Objects, prototype, constructor, & Object constructor](/javascript-objects-prototype-constructor/)\\n3. [Object Creation in JavaScript](/object-creation-in-javascript/)\\n4. [JavaScript OOP : Abstraction](/pillars-of-object-oriented-programming-abstraction-2/)\\n5. [JavaScript OOP : Encapsulation](/pillars-of-object-oriented-programming-encapsulation/)\\n6. [JavaScript OOP : Inheritance](/pillars-of-object-oriented-programming-inheritance)\\n7. [JavaScript OOP : Polymorphism](/pillars-of-object-oriented-programming-polymorphism)\\n8. [JavaScript OOP : Inheritance vs Composition]()\\n\\n\\nIn the previous part of this series, we went through JavaScript objects and how they work under the hood. As a refresher, JavaScript objects are created at the low-level using __new Object()__. We will go through Object creation in JavaScript, but bare in mind that almost everything in JavaScript revolves around objects, and inherit from Object's prototype.  Now let's examine different way how objects are created in JavaScript. In demonstrating object creation, we will focus on a representing a person.\\n\\n<p class=\\\"space\\\"></p>\\n\\n## Object constructor: _new Object()_;\\n\\nWe've previously gone through creating an object using the Object constructor, but it's worth mentioning again to help solidify the concept.\\n\\n<pre><code class=\\\"js\\\">\\n    var person = new Object();\\n    person.id = 123;\\n    person.firstname = \\\"John\\\";\\n    person.lastname = \\\"Fischer\\\"\\n    person.age = 24;\\n    person.showMove = function(){\\n        console.log(\\\"I can do a split!\\\");\\n    };\\n</code></pre>\\n\\n<p class=\\\"space\\\"></p>\\n\\n## Object Literals\\n\\nUsing the __new Object()__ constructor can be quite convoluted and lengthy, but object literals provide shortcut for creating objects, but under the hood, __new Object()__ is still being used.\\n\\n<pre><code class=\\\"js\\\">\\n    var person = {\\n        id: 123,\\n        firstname: \\\"John\\\",\\n        lastname: \\\"Fischer\\\",\\n        age: 24;\\n        showMove : function(){\\n            console.log(\\\"I can do a split!\\\");\\n        };\\n     }\\n</code></pre>\\n\\n<p class=\\\"space\\\"></p>\\n\\n### <b>Patterns for creating Objects</b>  \\n\\n<b>Constructor Functions</b>\\n\\nConstructor functions try to emulate the concept of classes in strongly typed languages such as C# and Java. There are some convention to adhere to though. The naming convention for constructor function starts with uppercase letter and the rest lowe-case letters.\\n\\n<span class=\\\"text-danger\\\">__Note:__</span> *==Functions are also objects. A function's prototype points to/inherits from Object which is the root object in JavaScript==*\\n\\n\\n<pre><code class=\\\"js\\\">\\n    function Person(firstname, lastname, age) {\\n      this.firstname = firstname;\\n      this.lastname = lastname;\\n      this.age = age;\\n      this.showMove = function(){\\n        console.log(\\\"I can do a split!\\\");\\n      }\\n\\n    }\\n</code></pre>\\n\\nWith this pattern, all kind of Person object can be created say, Bob and Alice.\\n\\n<pre><code class=\\\"js\\\">\\n    let alice = new Person(\\\"Alice\\\", \\\"Guru\\\", 27);\\n    let bob = new Person(\\\"Bob\\\", \\\"Don\\\", 32);\\n</code></pre>\\n\\nWe now have Alice and Bob objects, and more can be created, but always pay attention that the constructor function is __always__ instantiated or activated with the _new_ keyword. \\n\\n<p class=\\\"space\\\"></p>\\n\\n<b>Factory function</b>\\nFactory function is a pattern for creating objects, and it's reusable. We see how this function can be used to enforce privacy in later series. For now, let's see how to create object using the factory pattern.\\n\\n<pre><code class=\\\"js\\\">\\n    function createPerson(firstname, lastname, age) {\\n      return {\\n        firstname,\\n        lastname,\\n        age,\\n        showMove: function(){\\n            console.log(\\\"I can do a split!\\\");\\n        }\\n      }\\n\\n    }\\n    \\n    let alice = createPerson(\\\"Alice\\\", \\\"Guru\\\", 27);\\n    let bob = createPerson(\\\"Bob\\\", \\\"Don\\\", 32);\\n</code></pre>\\n\\n<p class=\\\"space\\\"></p>\\n\\n<b>Prototype pattern</b>\\nObjects can also be created in JavaScript using prototype property of an object.  *Remember* that every created object in JavaScript automatically has a prototype at the time of creation. Let's see how we can use prototype to create an object.\\n\\n<pre><code class=\\\"js\\\">\\n    function Person() {\\n    }\\n    \\n    Person.prototype.firstname = \\\"Bob\\\";\\n    Person.prototype.lastname = \\\"Guru\\\";\\n    Person.prototype.age = 24;\\n    Person.prototype.showMove = function(){\\n      console.log(\\\"I can do a split!\\\");\\n    }\\n    \\n</code></pre>\\n\\nWe shall examine prototype property further as it holds the key to OOP in JavaScript.\\n\\nThis concludes the objection creation series. We'll use all we've learned so far in the next coming series to really make sense of OOP in JavaScript.\\n\\nHappy coding.\"}]],\"markups\":[],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:</p>\n<p>This series is as follows:</p>\n<ol>\n<li><a href=\"/pillars-of-objected-oriented-programming\">Pillars of Objected-Oriented Programming</a></li>\n<li><a href=\"/javascript-objects-prototype-constructor/\">JavaScript Objects, prototype, constructor, &amp; Object constructor</a></li>\n<li><a href=\"/object-creation-in-javascript/\">Object Creation in JavaScript</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-abstraction-2/\">JavaScript OOP : Abstraction</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-encapsulation/\">JavaScript OOP : Encapsulation</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-inheritance\">JavaScript OOP : Inheritance</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-polymorphism\">JavaScript OOP : Polymorphism</a></li>\n<li><a href=\"\">JavaScript OOP : Inheritance vs Composition</a></li>\n</ol>\n<p>In the previous part of this series, we went through JavaScript objects and how they work under the hood. As a refresher, JavaScript objects are created at the low-level using <strong>new Object()</strong>. We will go through Object creation in JavaScript, but bare in mind that almost everything in JavaScript revolves around objects, and inherit from Object's prototype.  Now let's examine different way how objects are created in JavaScript. In demonstrating object creation, we will focus on a representing a person.</p>\n<p class=\"space\"></p>\n<h2 id=\"objectconstructornewobject\">Object constructor: <em>new Object()</em>;</h2>\n<p>We've previously gone through creating an object using the Object constructor, but it's worth mentioning again to help solidify the concept.</p>\n<pre><code class=\"js\">\n    var person = new Object();\n    person.id = 123;\n    person.firstname = \"John\";\n    person.lastname = \"Fischer\"\n    person.age = 24;\n    person.showMove = function(){\n        console.log(\"I can do a split!\");\n    };\n</code></pre>\n<p class=\"space\"></p>\n<h2 id=\"objectliterals\">Object Literals</h2>\n<p>Using the <strong>new Object()</strong> constructor can be quite convoluted and lengthy, but object literals provide shortcut for creating objects, but under the hood, <strong>new Object()</strong> is still being used.</p>\n<pre><code class=\"js\">\n    var person = {\n        id: 123,\n        firstname: \"John\",\n        lastname: \"Fischer\",\n        age: 24;\n        showMove : function(){\n            console.log(\"I can do a split!\");\n        };\n     }\n</code></pre>\n<p class=\"space\"></p>\n<h3 id=\"bpatternsforcreatingobjectsb\"><b>Patterns for creating Objects</b></h3>\n<p><b>Constructor Functions</b></p>\n<p>Constructor functions try to emulate the concept of classes in strongly typed languages such as C# and Java. There are some convention to adhere to though. The naming convention for constructor function starts with uppercase letter and the rest lowe-case letters.</p>\n<p><span class=\"text-danger\"><strong>Note:</strong></span> <em><mark>Functions are also objects. A function's prototype points to/inherits from Object which is the root object in JavaScript</mark></em></p>\n<pre><code class=\"js\">\n    function Person(firstname, lastname, age) {\n      this.firstname = firstname;\n      this.lastname = lastname;\n      this.age = age;\n      this.showMove = function(){\n        console.log(\"I can do a split!\");\n      }\n\n    }\n</code></pre>\n<p>With this pattern, all kind of Person object can be created say, Bob and Alice.</p>\n<pre><code class=\"js\">\n    let alice = new Person(\"Alice\", \"Guru\", 27);\n    let bob = new Person(\"Bob\", \"Don\", 32);\n</code></pre>\n<p>We now have Alice and Bob objects, and more can be created, but always pay attention that the constructor function is <strong>always</strong> instantiated or activated with the <em>new</em> keyword.</p>\n<p class=\"space\"></p>\n<p><b>Factory function</b><br>\nFactory function is a pattern for creating objects, and it's reusable. We see how this function can be used to enforce privacy in later series. For now, let's see how to create object using the factory pattern.</p>\n<pre><code class=\"js\">\n    function createPerson(firstname, lastname, age) {\n      return {\n        firstname,\n        lastname,\n        age,\n        showMove: function(){\n            console.log(\"I can do a split!\");\n        }\n      }\n\n    }\n    \n    let alice = createPerson(\"Alice\", \"Guru\", 27);\n    let bob = createPerson(\"Bob\", \"Don\", 32);\n</code></pre>\n<p class=\"space\"></p>\n<p><b>Prototype pattern</b><br>\nObjects can also be created in JavaScript using prototype property of an object.  <em>Remember</em> that every created object in JavaScript automatically has a prototype at the time of creation. Let's see how we can use prototype to create an object.</p>\n<pre><code class=\"js\">\n    function Person() {\n    }\n    \n    Person.prototype.firstname = \"Bob\";\n    Person.prototype.lastname = \"Guru\";\n    Person.prototype.age = 24;\n    Person.prototype.showMove = function(){\n      console.log(\"I can do a split!\");\n    }\n    \n</code></pre>\n<p>We shall examine prototype property further as it holds the key to OOP in JavaScript.</p>\n<p>This concludes the objection creation series. We'll use all we've learned so far in the next coming series to really make sense of OOP in JavaScript.</p>\n<p>Happy coding.</p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5ae569f4d8240f1f647a63c4",
    "plaintext": "This post is part of a series of posts on JavaScript object-oriented\nprogramming. Link to the series are as follows:\n\nThis series is as follows:\n\n 1. Pillars of Objected-Oriented Programming\n    [/pillars-of-objected-oriented-programming]\n 2. JavaScript Objects, prototype, constructor, & Object constructor\n    [/javascript-objects-prototype-constructor/]\n 3. Object Creation in JavaScript [/object-creation-in-javascript/]\n 4. JavaScript OOP : Abstraction\n    [/pillars-of-object-oriented-programming-abstraction-2/]\n 5. JavaScript OOP : Encapsulation\n    [/pillars-of-object-oriented-programming-encapsulation/]\n 6. JavaScript OOP : Inheritance\n    [/pillars-of-object-oriented-programming-inheritance]\n 7. JavaScript OOP : Polymorphism\n    [/pillars-of-object-oriented-programming-polymorphism]\n 8. JavaScript OOP : Inheritance vs Composition\n\nIn the previous part of this series, we went through JavaScript objects and how\nthey work under the hood. As a refresher, JavaScript objects are created at the\nlow-level using new Object(). We will go through Object creation in JavaScript,\nbut bare in mind that almost everything in JavaScript revolves around objects,\nand inherit from Object's prototype. Now let's examine different way how objects\nare created in JavaScript. In demonstrating object creation, we will focus on a\nrepresenting a person.\n\n\n\nObject constructor: new Object();\nWe've previously gone through creating an object using the Object constructor,\nbut it's worth mentioning again to help solidify the concept.\n\n\n    var person = new Object();\n    person.id = 123;\n    person.firstname = \"John\";\n    person.lastname = \"Fischer\"\n    person.age = 24;\n    person.showMove = function(){\n        console.log(\"I can do a split!\");\n    };\n\n\n\n\nObject Literals\nUsing the new Object() constructor can be quite convoluted and lengthy, but\nobject literals provide shortcut for creating objects, but under the hood, new\nObject() is still being used.\n\n\n    var person = {\n        id: 123,\n        firstname: \"John\",\n        lastname: \"Fischer\",\n        age: 24;\n        showMove : function(){\n            console.log(\"I can do a split!\");\n        };\n     }\n\n\n\n\nPatterns for creating Objects\nConstructor Functions\n\nConstructor functions try to emulate the concept of classes in strongly typed\nlanguages such as C# and Java. There are some convention to adhere to though.\nThe naming convention for constructor function starts with uppercase letter and\nthe rest lowe-case letters.\n\nNote: Functions are also objects. A function's prototype points to/inherits from\nObject which is the root object in JavaScript\n\n\n    function Person(firstname, lastname, age) {\n      this.firstname = firstname;\n      this.lastname = lastname;\n      this.age = age;\n      this.showMove = function(){\n        console.log(\"I can do a split!\");\n      }\n\n    }\n\n\nWith this pattern, all kind of Person object can be created say, Bob and Alice.\n\n\n    let alice = new Person(\"Alice\", \"Guru\", 27);\n    let bob = new Person(\"Bob\", \"Don\", 32);\n\n\nWe now have Alice and Bob objects, and more can be created, but always pay\nattention that the constructor function is always instantiated or activated with\nthe new keyword.\n\n\n\nFactory function\nFactory function is a pattern for creating objects, and it's reusable. We see\nhow this function can be used to enforce privacy in later series. For now, let's\nsee how to create object using the factory pattern.\n\n\n    function createPerson(firstname, lastname, age) {\n      return {\n        firstname,\n        lastname,\n        age,\n        showMove: function(){\n            console.log(\"I can do a split!\");\n        }\n      }\n\n    }\n    \n    let alice = createPerson(\"Alice\", \"Guru\", 27);\n    let bob = createPerson(\"Bob\", \"Don\", 32);\n\n\n\n\nPrototype pattern\nObjects can also be created in JavaScript using prototype property of an object. \nRemember that every created object in JavaScript automatically has a prototype\nat the time of creation. Let's see how we can use prototype to create an object.\n\n\n    function Person() {\n    }\n    \n    Person.prototype.firstname = \"Bob\";\n    Person.prototype.lastname = \"Guru\";\n    Person.prototype.age = 24;\n    Person.prototype.showMove = function(){\n      console.log(\"I can do a split!\");\n    }\n    \n\n\nWe shall examine prototype property further as it holds the key to OOP in\nJavaScript.\n\nThis concludes the objection creation series. We'll use all we've learned so far\nin the next coming series to really make sense of OOP in JavaScript.\n\nHappy coding.",
    "feature_image": "https://images.unsplash.com/photo-1527612820672-5b56351f7346?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ",
    "featured": 0,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-29 06:45:08",
    "updated_at": "2019-07-07 18:53:07",
    "published_at": "2018-05-02 15:55:00",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7e9",
    "uuid": "60499792-79c8-42c1-bfed-5b1474ab165a",
    "title": "JavaScript OOP : Encapsulation",
    "slug": "pillars-of-object-oriented-programming-encapsulation",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:  \\n\\nThis series is as follows:\\n\\n1.  [Pillars of Objected-Oriented Programming](/pillars-of-objected-oriented-programming)\\n2. [JavaScript Objects, prototype, constructor, & Object constructor](/javascript-objects-prototype-constructor/)\\n3. [Object Creation in JavaScript](/object-creation-in-javascript/)\\n4. [JavaScript OOP : Abstraction](/pillars-of-object-oriented-programming-abstraction-2/)\\n5. [JavaScript OOP : Encapsulation](/pillars-of-object-oriented-programming-encapsulation/)\\n6. [JavaScript OOP : Inheritance](/pillars-of-object-oriented-programming-inheritance)\\n7. [JavaScript OOP : Polymorphism](/pillars-of-object-oriented-programming-polymorphism)\\n8. [JavaScript OOP : Inheritance vs Composition]()\\n\\n\\nLet's demystify encapsulation in this episode. As a reminder, __encapsulation__ ==**is all about information hiding.**== In a simple sentence, this means we as developers should try by all means to ensure our internal implementation details never leak to the outside or specific property never get accessed from the outside and also not modifiable from the outside if our intention is not to do so.   \\n\\nBy design, JavaScript doesn't have the concept of private access modifiers like in strongly typed languages like C# and Java, but they are ways to ensure a property not intended to be accessed from the outside remains so. We will be looking at ways to ensure encapsulation for our object. We will continue to examine the CassettePlayer object from the last episode:\\n\\n<pre><code>\\n    function CassettePlayer(cassette){\\n      this.cassette = cassette;\\n\\n      this.play = function(){\\n        console.log(`I am playing ${this.cassette}`);\\n      };\\n      \\n      this.pause = function(){\\n        //pause cassette\\n      }\\n\\n      this.stop = function(){\\n        //stop playing\\n      };\\n\\n      this.record = function(){\\n        //record onto a cassette\\n      };\\n\\n      this.forward = function(){\\n        //forward cassette\\n      };\\n\\n      this.rewind = function(){\\n        //rewind cassette\\n      };\\n\\n      this.eject = function(){\\n        //eject cassette\\n      };\\n    }\\n</code></pre>\\n\\n<pre><code>\\n    let cassetPlayer = new CassettePlayer(\\\"Hip-hop\\\");\\n    cassetPlayer.play() // I am playing Hip-hop\\n</code></pre>\\n\\nVisualising the CassettePlayer's property:\\n\\n![abstraction](https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2Fimage.png?v=1562526047200)\\n\\nIf you've been following you must have noticed I mentioned there was an issue in the previous post and how we are going to use encapsulation to solve the problem.\\n\\nthe  **this.cassette** property of the CassettePlayer object is not meant to be accessed or modified from outside. This is dangerous as anyone can cause the state of our object to change intentionally or by accident. It is possible to do something like **cassetPlayer.cassette = \\\"something else\\\"** This should never happen as the CassettePlayer object depends or make use of this property internally.\\n\\nLet's see how to resolve the problem encapsulating away internal property: To make them private and not accessible from the outside.\\n\\n**let & const keywords**\\nThe let and const are introduced to JavaScript in the ECMAScript 6 or ES6 features. They are block-scoped modifiers, meaning if you declare a variable with the **let** or **const** keyword, that variable will only be accessible within the block it was declared.One fundamental difference between let and const is that once you declare a variable using const, value of that variable cannot be changed. Apply that to our CassettePlayer object we have:\\n\\n<pre><code>\\n    function CassettePlayer(cassette){\\n      const _cassette = cassette;\\n\\n      this.play = function(){\\n        console.log(`I am playing ${this.cassette}`);\\n      };\\n\\n      this.pause = function(){\\n        //pause cassette\\n      }\\n\\n      this.stop = function(){\\n        //stop playing\\n      };\\n\\n      this.record = function(){\\n        //record onto a cassette\\n      };\\n\\n      this.forward = function(){\\n        //forward cassette\\n      };\\n\\n      this.rewind = function(){\\n        //rewind cassette\\n      };\\n\\n      this.eject = function(){\\n        //eject cassette\\n      };\\n    }\\n    \\n    let cassettePlayer = new CassettePlayer(\\\"Hip hop\\\");\\n    cassettePlayer.play();\\n\\n    console.log(cassettePlayer);\\n    \\n</code></pre>\\n\\n![encapsulate](https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2FScreenshot%202019-07-07%20at%2020.21.19.png?v=1562527311357)\\n\\n Our internal variable is now concealed and not accessible from the outside. The CassettePlayer object now satisfies abstraction and encapsulation.\\n \\n\\n**Revealing Module Pattern**\\nThe Revealing module pattern is a JavaScript design pattern that supports and enforces encapsulation. This pattern helps you decide what you want to expose and not expose. Let have a look:\\n\\n<pre><code>\\n    function cassettePlayer(cassette){\\n\\n      var _cassette = cassette;\\n\\n      function play(){ console.log(`I am playing ${_cassette}`); }\\n\\n      function pause(){}\\n\\n      function stop(){}\\n\\n      function record(){}\\n\\n      function forward(){}\\n\\n      function rewind(){}\\n\\n      function eject(){}\\n      function connectToWifi(){} // Not accessible!\\n\\n      return {\\n        play: play,\\n        pause: pause,\\n        stop: stop,\\n        record: record,\\n        forward: forward,\\n        rewind: rewind,\\n        eject: eject\\n      };\\n    }\\n</code></pre>\\n\\n![revealing-pattern](https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2FScreenshot%202019-07-07%20at%2020.21.19.png?v=1562527311357)\\n\\nThe connect connectToWifi property is not accessible from the outside even if you try to access it.\\n\\nBy all means, this is not the exhaustive list of how to create private properties in JavaScript. In other not to get too ahead of ourselves, we'll stick to these for now. If you want to explore further,  have a look at [ES6 symbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) and [weakMaps](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap). Symbols and weakMaps can also be used to create private properties. We will be exploring them further in the future post on ES6.\\n\\nI hope you have learned something new today.\\n\\nHappy coding.\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:</p>\n<p>This series is as follows:</p>\n<ol>\n<li><a href=\"/pillars-of-objected-oriented-programming\">Pillars of Objected-Oriented Programming</a></li>\n<li><a href=\"/javascript-objects-prototype-constructor/\">JavaScript Objects, prototype, constructor, &amp; Object constructor</a></li>\n<li><a href=\"/object-creation-in-javascript/\">Object Creation in JavaScript</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-abstraction-2/\">JavaScript OOP : Abstraction</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-encapsulation/\">JavaScript OOP : Encapsulation</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-inheritance\">JavaScript OOP : Inheritance</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-polymorphism\">JavaScript OOP : Polymorphism</a></li>\n<li><a href=\"\">JavaScript OOP : Inheritance vs Composition</a></li>\n</ol>\n<p>Let's demystify encapsulation in this episode. As a reminder, <strong>encapsulation</strong> <mark><strong>is all about information hiding.</strong></mark> In a simple sentence, this means we as developers should try by all means to ensure our internal implementation details never leak to the outside or specific property never get accessed from the outside and also not modifiable from the outside if our intention is not to do so.</p>\n<p>By design, JavaScript doesn't have the concept of private access modifiers like in strongly typed languages like C# and Java, but they are ways to ensure a property not intended to be accessed from the outside remains so. We will be looking at ways to ensure encapsulation for our object. We will continue to examine the CassettePlayer object from the last episode:</p>\n<pre><code>\n    function CassettePlayer(cassette){\n      this.cassette = cassette;\n\n      this.play = function(){\n        console.log(`I am playing ${this.cassette}`);\n      };\n      \n      this.pause = function(){\n        //pause cassette\n      }\n\n      this.stop = function(){\n        //stop playing\n      };\n\n      this.record = function(){\n        //record onto a cassette\n      };\n\n      this.forward = function(){\n        //forward cassette\n      };\n\n      this.rewind = function(){\n        //rewind cassette\n      };\n\n      this.eject = function(){\n        //eject cassette\n      };\n    }\n</code></pre>\n<pre><code>\n    let cassetPlayer = new CassettePlayer(\"Hip-hop\");\n    cassetPlayer.play() // I am playing Hip-hop\n</code></pre>\n<p>Visualising the CassettePlayer's property:</p>\n<p><img src=\"https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2Fimage.png?v=1562526047200\" alt=\"abstraction\"></p>\n<p>If you've been following you must have noticed I mentioned there was an issue in the previous post and how we are going to use encapsulation to solve the problem.</p>\n<p>the  <strong>this.cassette</strong> property of the CassettePlayer object is not meant to be accessed or modified from outside. This is dangerous as anyone can cause the state of our object to change intentionally or by accident. It is possible to do something like <strong>cassetPlayer.cassette = &quot;something else&quot;</strong> This should never happen as the CassettePlayer object depends or make use of this property internally.</p>\n<p>Let's see how to resolve the problem encapsulating away internal property: To make them private and not accessible from the outside.</p>\n<p><strong>let &amp; const keywords</strong><br>\nThe let and const are introduced to JavaScript in the ECMAScript 6 or ES6 features. They are block-scoped modifiers, meaning if you declare a variable with the <strong>let</strong> or <strong>const</strong> keyword, that variable will only be accessible within the block it was declared.One fundamental difference between let and const is that once you declare a variable using const, value of that variable cannot be changed. Apply that to our CassettePlayer object we have:</p>\n<pre><code>\n    function CassettePlayer(cassette){\n      const _cassette = cassette;\n\n      this.play = function(){\n        console.log(`I am playing ${this.cassette}`);\n      };\n\n      this.pause = function(){\n        //pause cassette\n      }\n\n      this.stop = function(){\n        //stop playing\n      };\n\n      this.record = function(){\n        //record onto a cassette\n      };\n\n      this.forward = function(){\n        //forward cassette\n      };\n\n      this.rewind = function(){\n        //rewind cassette\n      };\n\n      this.eject = function(){\n        //eject cassette\n      };\n    }\n    \n    let cassettePlayer = new CassettePlayer(\"Hip hop\");\n    cassettePlayer.play();\n\n    console.log(cassettePlayer);\n    \n</code></pre>\n<p><img src=\"https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2FScreenshot%202019-07-07%20at%2020.21.19.png?v=1562527311357\" alt=\"encapsulate\"></p>\n<p>Our internal variable is now concealed and not accessible from the outside. The CassettePlayer object now satisfies abstraction and encapsulation.</p>\n<p><strong>Revealing Module Pattern</strong><br>\nThe Revealing module pattern is a JavaScript design pattern that supports and enforces encapsulation. This pattern helps you decide what you want to expose and not expose. Let have a look:</p>\n<pre><code>\n    function cassettePlayer(cassette){\n\n      var _cassette = cassette;\n\n      function play(){ console.log(`I am playing ${_cassette}`); }\n\n      function pause(){}\n\n      function stop(){}\n\n      function record(){}\n\n      function forward(){}\n\n      function rewind(){}\n\n      function eject(){}\n      function connectToWifi(){} // Not accessible!\n\n      return {\n        play: play,\n        pause: pause,\n        stop: stop,\n        record: record,\n        forward: forward,\n        rewind: rewind,\n        eject: eject\n      };\n    }\n</code></pre>\n<p><img src=\"https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2FScreenshot%202019-07-07%20at%2020.21.19.png?v=1562527311357\" alt=\"revealing-pattern\"></p>\n<p>The connect connectToWifi property is not accessible from the outside even if you try to access it.</p>\n<p>By all means, this is not the exhaustive list of how to create private properties in JavaScript. In other not to get too ahead of ourselves, we'll stick to these for now. If you want to explore further,  have a look at <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">ES6 symbols</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\">weakMaps</a>. Symbols and weakMaps can also be used to create private properties. We will be exploring them further in the future post on ES6.</p>\n<p>I hope you have learned something new today.</p>\n<p>Happy coding.</p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5ae56a02d8240f1f647a63c6",
    "plaintext": "This post is part of a series of posts on JavaScript object-oriented\nprogramming. Link to the series are as follows:\n\nThis series is as follows:\n\n 1. Pillars of Objected-Oriented Programming\n    [/pillars-of-objected-oriented-programming]\n 2. JavaScript Objects, prototype, constructor, & Object constructor\n    [/javascript-objects-prototype-constructor/]\n 3. Object Creation in JavaScript [/object-creation-in-javascript/]\n 4. JavaScript OOP : Abstraction\n    [/pillars-of-object-oriented-programming-abstraction-2/]\n 5. JavaScript OOP : Encapsulation\n    [/pillars-of-object-oriented-programming-encapsulation/]\n 6. JavaScript OOP : Inheritance\n    [/pillars-of-object-oriented-programming-inheritance]\n 7. JavaScript OOP : Polymorphism\n    [/pillars-of-object-oriented-programming-polymorphism]\n 8. JavaScript OOP : Inheritance vs Composition\n\nLet's demystify encapsulation in this episode. As a reminder, encapsulation is\nall about information hiding. In a simple sentence, this means we as developers\nshould try by all means to ensure our internal implementation details never leak\nto the outside or specific property never get accessed from the outside and also\nnot modifiable from the outside if our intention is not to do so.\n\nBy design, JavaScript doesn't have the concept of private access modifiers like\nin strongly typed languages like C# and Java, but they are ways to ensure a\nproperty not intended to be accessed from the outside remains so. We will be\nlooking at ways to ensure encapsulation for our object. We will continue to\nexamine the CassettePlayer object from the last episode:\n\n\n    function CassettePlayer(cassette){\n      this.cassette = cassette;\n\n      this.play = function(){\n        console.log(`I am playing ${this.cassette}`);\n      };\n      \n      this.pause = function(){\n        //pause cassette\n      }\n\n      this.stop = function(){\n        //stop playing\n      };\n\n      this.record = function(){\n        //record onto a cassette\n      };\n\n      this.forward = function(){\n        //forward cassette\n      };\n\n      this.rewind = function(){\n        //rewind cassette\n      };\n\n      this.eject = function(){\n        //eject cassette\n      };\n    }\n\n\n\n    let cassetPlayer = new CassettePlayer(\"Hip-hop\");\n    cassetPlayer.play() // I am playing Hip-hop\n\n\nVisualising the CassettePlayer's property:\n\n\n\nIf you've been following you must have noticed I mentioned there was an issue in\nthe previous post and how we are going to use encapsulation to solve the\nproblem.\n\nthe this.cassette property of the CassettePlayer object is not meant to be\naccessed or modified from outside. This is dangerous as anyone can cause the\nstate of our object to change intentionally or by accident. It is possible to do\nsomething like cassetPlayer.cassette = \"something else\" This should never happen\nas the CassettePlayer object depends or make use of this property internally.\n\nLet's see how to resolve the problem encapsulating away internal property: To\nmake them private and not accessible from the outside.\n\nlet & const keywords\nThe let and const are introduced to JavaScript in the ECMAScript 6 or ES6\nfeatures. They are block-scoped modifiers, meaning if you declare a variable\nwith the let or const keyword, that variable will only be accessible within the\nblock it was declared.One fundamental difference between let and const is that\nonce you declare a variable using const, value of that variable cannot be\nchanged. Apply that to our CassettePlayer object we have:\n\n\n    function CassettePlayer(cassette){\n      const _cassette = cassette;\n\n      this.play = function(){\n        console.log(`I am playing ${this.cassette}`);\n      };\n\n      this.pause = function(){\n        //pause cassette\n      }\n\n      this.stop = function(){\n        //stop playing\n      };\n\n      this.record = function(){\n        //record onto a cassette\n      };\n\n      this.forward = function(){\n        //forward cassette\n      };\n\n      this.rewind = function(){\n        //rewind cassette\n      };\n\n      this.eject = function(){\n        //eject cassette\n      };\n    }\n    \n    let cassettePlayer = new CassettePlayer(\"Hip hop\");\n    cassettePlayer.play();\n\n    console.log(cassettePlayer);\n    \n\n\n\n\nOur internal variable is now concealed and not accessible from the outside. The\nCassettePlayer object now satisfies abstraction and encapsulation.\n\nRevealing Module Pattern\nThe Revealing module pattern is a JavaScript design pattern that supports and\nenforces encapsulation. This pattern helps you decide what you want to expose\nand not expose. Let have a look:\n\n\n    function cassettePlayer(cassette){\n\n      var _cassette = cassette;\n\n      function play(){ console.log(`I am playing ${_cassette}`); }\n\n      function pause(){}\n\n      function stop(){}\n\n      function record(){}\n\n      function forward(){}\n\n      function rewind(){}\n\n      function eject(){}\n      function connectToWifi(){} // Not accessible!\n\n      return {\n        play: play,\n        pause: pause,\n        stop: stop,\n        record: record,\n        forward: forward,\n        rewind: rewind,\n        eject: eject\n      };\n    }\n\n\n\n\nThe connect connectToWifi property is not accessible from the outside even if\nyou try to access it.\n\nBy all means, this is not the exhaustive list of how to create private\nproperties in JavaScript. In other not to get too ahead of ourselves, we'll\nstick to these for now. If you want to explore further, have a look at ES6\nsymbols\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol] \nand weakMaps\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap]\n. Symbols and weakMaps can also be used to create private properties. We will be\nexploring them further in the future post on ES6.\n\nI hope you have learned something new today.\n\nHappy coding.",
    "feature_image": "https://images.unsplash.com/photo-1511560941362-2e0171b73d6c?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=8285be63e15ffbe1c8bf22c33d280438",
    "featured": 0,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-29 06:45:22",
    "updated_at": "2019-07-07 19:26:36",
    "published_at": "2018-05-04 03:38:00",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7ea",
    "uuid": "3019c00d-1718-4e09-8c4c-939ae3881627",
    "title": "JavaScript OOP : Inheritance",
    "slug": "pillars-of-object-oriented-programming-inheritance",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:  \\n\\nThis series is as follows:\\n\\n1.  [Pillars of Objected-Oriented Programming](/pillars-of-objected-oriented-programming)\\n2. [JavaScript Objects, prototype, constructor, & Object constructor](/javascript-objects-prototype-constructor/)\\n3. [Object Creation in JavaScript](/object-creation-in-javascript/)\\n4. [JavaScript OOP : Abstraction](/pillars-of-object-oriented-programming-abstraction-2/)\\n5. [JavaScript OOP : Encapsulation](/pillars-of-object-oriented-programming-encapsulation/)\\n6. [JavaScript OOP : Inheritance](/pillars-of-object-oriented-programming-inheritance)\\n7. [JavaScript OOP : Polymorphism](/pillars-of-object-oriented-programming-polymorphism)\\n8. [JavaScript OOP : Inheritance vs Composition]()\\n\\n<p class=\\\"space\\\"></p>\\n\\nIf you are still following this series, then you are doing really fine. Today we will continue this series with __inheritance__.  \\n\\nJavaScript doesn't have the concept of classes like in other programming languages like C# or Java. While ES6 introduces the concept of classes, it's just a wrapper around object. _**Everything in JavaScript is object**_ We will further explain what that means when we talk about ES6 classes.  \\n\\nIf you remember, we talked about prototype in our [previous post](/javascript-objects-prototype-constructor/) Prototype holds the key to truly understand object-oriented programming in JavaScript. _**Prototype in JavaScript is simply, parent of another object**_. So when I use the word prototype, I am referring to the parent of an object _e.g If object B inherits from object A, then B's prototype is A_.  \\n\\n#Prototypical Inheritance\\n> ==**Inheritance is the ability of an object to take on the property and method of another object**==. Meaning if object B inherits from object A, then object B should have all the properties and behaviours of object A.  \\n\\nTo help solidify JavaScript OOP, we will use the analogy of shapes like Square, Circle, Triangle to illustrate this concept. Suppose we are tasked to implement a solution to store and keep tracks of different shapes, how would we go about designing our system conforming to OOP?  \\n\\nOur focus is on **inheritance** right now. Let's design out shape application. A shape object with a basic property or method that knows how to draw shapes.  \\n\\n<pre><code>\\n    function Shape(){\\n    }\\n\\n    Shape.prototype.draw = function(){\\n      console.log(\\\"This shape is drawn\\\");\\n    };\\n</code></pre>\\n\\nNow we have a base object (Shape) which will serve as a prototype (or parent) to other types of shapes we will implement.  Let's create a circle shape that inherits from our base Shape object.\\n\\n<pre><code>\\n    function Circle(radius){\\n      this.radius = radius;\\n    }\\n\\n    //Circle inherits from Shape object\\n    Circle.prototype = Object.create(Shape.prototype);\\n\\n    //Setting the constructor to Circle object\\n    //to allow for creation of new Circle Object\\n    Circle.prototype.constructor = Circle;\\n</code></pre>\\n\\nThe parent object (Shape) has a property draw  which is inherited by the the child object (Circle).\\n\\n![childfunc](/content/images/2018/07/childfunc.png?w=600&q=80&style=center)  \\n\\nNow let's give each shape object color and names without repeating codes. We will further add other shapes such as triangle and rectangle. The list can go on and on for all possible shapes. However, we will stick to few shapes.\\n\\n\\n<pre><code>\\n    function Shape(color, name){\\n        this.color = color;\\n        this.name = name;\\n    }\\n\\n    Shape.prototype.draw = function(){\\n      console.log(`${this.name} with color ${this.color} is drawn!`);\\n    };\\n\\n\\n    //Circle Shape\\n    function Circle(radius, name, color){\\n        Shape.call(this, color, name); //Calling the base or parent class\\n        this.radius = radius;\\n      }\\n\\n      //Circle inherit from Shape\\n      inherit(Shape, Circle);\\n\\n\\n    //Triangle Shape\\n    function Triangle(base, height, name, color){\\n        Shape.call(this, color, name);\\n        this.base = base;\\n        this.height = height;\\n      }\\n\\n      //Triangle inherit from Shape\\n      inherit(Shape, Triangle);\\n\\n\\n      //Rectangle Shape\\n    function Rectangle(length, breath, name, color){\\n        Shape.call(this, color, name);\\n        this.length = length;\\n        this.breath = breath;\\n      }\\n\\n      //Rectangle inherit from Shape\\n      inherit(Shape, Rectangle);\\n\\n\\n    function inherit(Parent, Child){\\n        Child.prototype = Object.create(Parent.prototype);\\n        Child.prototype.constructor = Child;\\n    }\\n</code></pre>  \\n\\nNow we have different shapes implementing or inheriting from the Shape object. Let's have a quick look how the children object behave. I have encapsulated the two lines of code of changing the prototypes into a re-usable function inherit to make our code easy to read.\\n\\n<pre><code>\\n    let circle = new Circle(10, 'Circle', 'red'),\\n        triangle = new Triangle(5, 10, 'triangle', 'black'),\\n        rectangle = new Rectangle(10, 10, 'rectangle', 'blue');\\n</code></pre>\\n\\n![output](/content/images/2018/07/output.png?w=600&q=80&style=center)\\n\\nIn addition to their proprties, all the children objects now have access to the parent(prototype) object property.\\n\\nThis completes the basis of inheritance in object-oriented JavaScript.\\n\\n\\nHappy Coding...\\n\"}]],\"markups\":[],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:</p>\n<p>This series is as follows:</p>\n<ol>\n<li><a href=\"/pillars-of-objected-oriented-programming\">Pillars of Objected-Oriented Programming</a></li>\n<li><a href=\"/javascript-objects-prototype-constructor/\">JavaScript Objects, prototype, constructor, &amp; Object constructor</a></li>\n<li><a href=\"/object-creation-in-javascript/\">Object Creation in JavaScript</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-abstraction-2/\">JavaScript OOP : Abstraction</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-encapsulation/\">JavaScript OOP : Encapsulation</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-inheritance\">JavaScript OOP : Inheritance</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-polymorphism\">JavaScript OOP : Polymorphism</a></li>\n<li><a href=\"\">JavaScript OOP : Inheritance vs Composition</a></li>\n</ol>\n<p class=\"space\"></p>\n<p>If you are still following this series, then you are doing really fine. Today we will continue this series with <strong>inheritance</strong>.</p>\n<p>JavaScript doesn't have the concept of classes like in other programming languages like C# or Java. While ES6 introduces the concept of classes, it's just a wrapper around object. <em><strong>Everything in JavaScript is object</strong></em> We will further explain what that means when we talk about ES6 classes.</p>\n<p>If you remember, we talked about prototype in our <a href=\"/javascript-objects-prototype-constructor/\">previous post</a> Prototype holds the key to truly understand object-oriented programming in JavaScript. <em><strong>Prototype in JavaScript is simply, parent of another object</strong></em>. So when I use the word prototype, I am referring to the parent of an object <em>e.g If object B inherits from object A, then B's prototype is A</em>.</p>\n<h1 id=\"prototypicalinheritance\">Prototypical Inheritance</h1>\n<blockquote>\n<p><mark><strong>Inheritance is the ability of an object to take on the property and method of another object</strong></mark>. Meaning if object B inherits from object A, then object B should have all the properties and behaviours of object A.</p>\n</blockquote>\n<p>To help solidify JavaScript OOP, we will use the analogy of shapes like Square, Circle, Triangle to illustrate this concept. Suppose we are tasked to implement a solution to store and keep tracks of different shapes, how would we go about designing our system conforming to OOP?</p>\n<p>Our focus is on <strong>inheritance</strong> right now. Let's design out shape application. A shape object with a basic property or method that knows how to draw shapes.</p>\n<pre><code>\n    function Shape(){\n    }\n\n    Shape.prototype.draw = function(){\n      console.log(\"This shape is drawn\");\n    };\n</code></pre>\n<p>Now we have a base object (Shape) which will serve as a prototype (or parent) to other types of shapes we will implement.  Let's create a circle shape that inherits from our base Shape object.</p>\n<pre><code>\n    function Circle(radius){\n      this.radius = radius;\n    }\n\n    //Circle inherits from Shape object\n    Circle.prototype = Object.create(Shape.prototype);\n\n    //Setting the constructor to Circle object\n    //to allow for creation of new Circle Object\n    Circle.prototype.constructor = Circle;\n</code></pre>\n<p>The parent object (Shape) has a property draw  which is inherited by the the child object (Circle).</p>\n<p><img src=\"/content/images/2018/07/childfunc.png?w=600&amp;q=80&amp;style=center\" alt=\"childfunc\"></p>\n<p>Now let's give each shape object color and names without repeating codes. We will further add other shapes such as triangle and rectangle. The list can go on and on for all possible shapes. However, we will stick to few shapes.</p>\n<pre><code>\n    function Shape(color, name){\n        this.color = color;\n        this.name = name;\n    }\n\n    Shape.prototype.draw = function(){\n      console.log(`${this.name} with color ${this.color} is drawn!`);\n    };\n\n\n    //Circle Shape\n    function Circle(radius, name, color){\n        Shape.call(this, color, name); //Calling the base or parent class\n        this.radius = radius;\n      }\n\n      //Circle inherit from Shape\n      inherit(Shape, Circle);\n\n\n    //Triangle Shape\n    function Triangle(base, height, name, color){\n        Shape.call(this, color, name);\n        this.base = base;\n        this.height = height;\n      }\n\n      //Triangle inherit from Shape\n      inherit(Shape, Triangle);\n\n\n      //Rectangle Shape\n    function Rectangle(length, breath, name, color){\n        Shape.call(this, color, name);\n        this.length = length;\n        this.breath = breath;\n      }\n\n      //Rectangle inherit from Shape\n      inherit(Shape, Rectangle);\n\n\n    function inherit(Parent, Child){\n        Child.prototype = Object.create(Parent.prototype);\n        Child.prototype.constructor = Child;\n    }\n</code></pre>  \n<p>Now we have different shapes implementing or inheriting from the Shape object. Let's have a quick look how the children object behave. I have encapsulated the two lines of code of changing the prototypes into a re-usable function inherit to make our code easy to read.</p>\n<pre><code>\n    let circle = new Circle(10, 'Circle', 'red'),\n        triangle = new Triangle(5, 10, 'triangle', 'black'),\n        rectangle = new Rectangle(10, 10, 'rectangle', 'blue');\n</code></pre>\n<p><img src=\"/content/images/2018/07/output.png?w=600&amp;q=80&amp;style=center\" alt=\"output\"></p>\n<p>In addition to their proprties, all the children objects now have access to the parent(prototype) object property.</p>\n<p>This completes the basis of inheritance in object-oriented JavaScript.</p>\n<p>Happy Coding...</p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5ae56a1ed8240f1f647a63ca",
    "plaintext": "This post is part of a series of posts on JavaScript object-oriented\nprogramming. Link to the series are as follows:\n\nThis series is as follows:\n\n 1. Pillars of Objected-Oriented Programming\n    [/pillars-of-objected-oriented-programming]\n 2. JavaScript Objects, prototype, constructor, & Object constructor\n    [/javascript-objects-prototype-constructor/]\n 3. Object Creation in JavaScript [/object-creation-in-javascript/]\n 4. JavaScript OOP : Abstraction\n    [/pillars-of-object-oriented-programming-abstraction-2/]\n 5. JavaScript OOP : Encapsulation\n    [/pillars-of-object-oriented-programming-encapsulation/]\n 6. JavaScript OOP : Inheritance\n    [/pillars-of-object-oriented-programming-inheritance]\n 7. JavaScript OOP : Polymorphism\n    [/pillars-of-object-oriented-programming-polymorphism]\n 8. JavaScript OOP : Inheritance vs Composition\n\n\n\nIf you are still following this series, then you are doing really fine. Today we\nwill continue this series with inheritance.\n\nJavaScript doesn't have the concept of classes like in other programming\nlanguages like C# or Java. While ES6 introduces the concept of classes, it's\njust a wrapper around object. Everything in JavaScript is object We will further\nexplain what that means when we talk about ES6 classes.\n\nIf you remember, we talked about prototype in our previous post\n[/javascript-objects-prototype-constructor/] Prototype holds the key to truly\nunderstand object-oriented programming in JavaScript. Prototype in JavaScript is\nsimply, parent of another object. So when I use the word prototype, I am\nreferring to the parent of an object e.g If object B inherits from object A,\nthen B's prototype is A.\n\nPrototypical Inheritance\n> Inheritance is the ability of an object to take on the property and method of\nanother object. Meaning if object B inherits from object A, then object B should\nhave all the properties and behaviours of object A.\n\n\nTo help solidify JavaScript OOP, we will use the analogy of shapes like Square,\nCircle, Triangle to illustrate this concept. Suppose we are tasked to implement\na solution to store and keep tracks of different shapes, how would we go about\ndesigning our system conforming to OOP?\n\nOur focus is on inheritance right now. Let's design out shape application. A\nshape object with a basic property or method that knows how to draw shapes.\n\n\n    function Shape(){\n    }\n\n    Shape.prototype.draw = function(){\n      console.log(\"This shape is drawn\");\n    };\n\n\nNow we have a base object (Shape) which will serve as a prototype (or parent) to\nother types of shapes we will implement. Let's create a circle shape that\ninherits from our base Shape object.\n\n\n    function Circle(radius){\n      this.radius = radius;\n    }\n\n    //Circle inherits from Shape object\n    Circle.prototype = Object.create(Shape.prototype);\n\n    //Setting the constructor to Circle object\n    //to allow for creation of new Circle Object\n    Circle.prototype.constructor = Circle;\n\n\nThe parent object (Shape) has a property draw which is inherited by the the\nchild object (Circle).\n\n\n\nNow let's give each shape object color and names without repeating codes. We\nwill further add other shapes such as triangle and rectangle. The list can go on\nand on for all possible shapes. However, we will stick to few shapes.\n\n\n    function Shape(color, name){\n        this.color = color;\n        this.name = name;\n    }\n\n    Shape.prototype.draw = function(){\n      console.log(`${this.name} with color ${this.color} is drawn!`);\n    };\n\n\n    //Circle Shape\n    function Circle(radius, name, color){\n        Shape.call(this, color, name); //Calling the base or parent class\n        this.radius = radius;\n      }\n\n      //Circle inherit from Shape\n      inherit(Shape, Circle);\n\n\n    //Triangle Shape\n    function Triangle(base, height, name, color){\n        Shape.call(this, color, name);\n        this.base = base;\n        this.height = height;\n      }\n\n      //Triangle inherit from Shape\n      inherit(Shape, Triangle);\n\n\n      //Rectangle Shape\n    function Rectangle(length, breath, name, color){\n        Shape.call(this, color, name);\n        this.length = length;\n        this.breath = breath;\n      }\n\n      //Rectangle inherit from Shape\n      inherit(Shape, Rectangle);\n\n\n    function inherit(Parent, Child){\n        Child.prototype = Object.create(Parent.prototype);\n        Child.prototype.constructor = Child;\n    }\n\n\nNow we have different shapes implementing or inheriting from the Shape object.\nLet's have a quick look how the children object behave. I have encapsulated the\ntwo lines of code of changing the prototypes into a re-usable function inherit\nto make our code easy to read.\n\n\n    let circle = new Circle(10, 'Circle', 'red'),\n        triangle = new Triangle(5, 10, 'triangle', 'black'),\n        rectangle = new Rectangle(10, 10, 'rectangle', 'blue');\n\n\n\n\nIn addition to their proprties, all the children objects now have access to the\nparent(prototype) object property.\n\nThis completes the basis of inheritance in object-oriented JavaScript.\n\nHappy Coding...",
    "feature_image": "https://images.unsplash.com/photo-1439920120577-eb3a83c16dd7?ixlib=rb-0.3.5&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ&s=1aaafd4c76b2ea3d4f8cbd3d860af489",
    "featured": 0,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-29 06:45:50",
    "updated_at": "2019-07-07 19:30:42",
    "published_at": "2018-07-23 10:47:51",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7eb",
    "uuid": "58b537f3-bcb8-48aa-902c-846c9107ffd5",
    "title": "JavaScript OOP : Inheritance vs Composition",
    "slug": "pillars-of-object-oriented-programming-inheritance-vs-composition",
    "mobiledoc": "{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"\"}]],\"sections\":[[10,0]]}",
    "html": null,
    "comment_id": "5ae56a27d8240f1f647a63cc",
    "plaintext": null,
    "feature_image": null,
    "featured": 0,
    "type": "post",
    "status": "draft",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-29 06:45:59",
    "updated_at": "2018-07-25 00:58:05",
    "published_at": null,
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7ec",
    "uuid": "c95f134d-97ed-4ee6-9741-9adcf41cc3c3",
    "title": "JavaScript OOP : Polymorphism",
    "slug": "pillars-of-object-oriented-programming-polymorphism",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:  \\n\\nThis series is as follows:\\n\\n1.  [Pillars of Objected-Oriented Programming](/pillars-of-objected-oriented-programming)\\n2. [JavaScript Objects, prototype, constructor, & Object constructor](/javascript-objects-prototype-constructor/)\\n3. [Object Creation in JavaScript](/object-creation-in-javascript/)\\n4. [JavaScript OOP : Abstraction](/pillars-of-object-oriented-programming-abstraction-2/)\\n5. [JavaScript OOP : Encapsulation](/pillars-of-object-oriented-programming-encapsulation/)\\n6. [JavaScript OOP : Inheritance](/pillars-of-object-oriented-programming-inheritance)\\n7. [JavaScript OOP : Polymorphism](/pillars-of-object-oriented-programming-polymorphism)\\n8. [JavaScript OOP : Inheritance vs Composition]()\\n\\n<p class=\\\"space\\\"></p>\\n\\nThis post is a continuation of the object-oriented programming in JavaScript where we discuss polymorphism.\\n\\n###What is polymorphism ?\\n==**Polymorphism in the ability to exist and appear in many forms**==.\\n\\n- _==Derived objects or subclass may be treated as objects of a base class such as collections of arrays==_\\n- _==Derived objects can override methods of a base object by providing their own implementations==_  \\n\\n\\nLet's explain this concepts in JavaScript while building upon the Shape object and its derived objects from the [inheritance](/pillars-of-object-oriented-programming-inheritance) post.  \\n\\n> *<p class=\\\"strong-point-highlight\\\">A Child object or subclass or derived object may be treated as a parent objects of a base class</p>*\\n\\nLet's borrow some code from the [inheritance](/pillars-of-object-oriented-programming-inheritance) post.\\n\\n\\n<pre><code>\\n    function Shape(color, name){\\n        this.color = color;\\n        this.name = name;\\n    }\\n\\n    Shape.prototype.draw = function(){\\n      console.log(`${this.name} with color ${this.color} is drawn!`);\\n    };\\n\\n\\n    //Circle Shape\\n    function Circle(radius, name, color){\\n        //Calling the base or parent class\\n        Shape.call(this, color, name);\\n        this.radius = radius;\\n      }\\n\\n      //Circle inherit from Shape\\n      inherit(Shape, Circle);\\n\\n\\n    //Triangle Shape\\n    function Triangle(base, height, name, color){\\n        Shape.call(this, color, name);\\n        this.radius = radius;\\n      }\\n\\n      //Triangle inherit from Shape\\n      inherit(Shape, Triangle);\\n\\n\\n      //Rectangle Shape\\n    function Rectangle(length, breath, name, color){\\n        Shape.call(this, color, name);\\n        this.radius = radius;\\n      }\\n\\n      //Rectangle inherit from Shape\\n      inherit(Shape, Rectangle);\\n\\n\\n    function inherit(Parent, Child){\\n        Child.prototype = Object.create(Parent.prototype);\\n        Child.prototype.constructor = Child;\\n    }\\n</code></pre> \\n\\nTreating all kinds of shape as a Shape object yet still able to behave in the form of the different shapes.\\n\\n<pre><code>\\n    const shapes = [\\n        new Circle(10, 'Circle', 'red'),\\n        new Triangle(5, 10, 'triangle', 'black'),\\n        new Rectangle(10, 10, 'rectangle', 'blue')\\n    ]\\n\\n    shapes.forEach(shape => shape.draw());\\n\\n    //Circle with color red is drawn!\\n    //triangle with color black is drawn!\\n    //rectangle with color blue is drawn!\\n</code></pre>  \\n\\nAll the shapes object are now treated like a single Shape object while they behave differently.\\n\\n<p class=\\\"space\\\"></p>  \\n<p class=\\\"space\\\"></p>  \\n\\n\\n*<p class=\\\"strong-point-highlight\\\">Derived objects can override methods of a base object by providing their own implementations</p>*  \\n\\nThis concept of having a child object overridding the parent's method is referred to as ==**method overriding**==. Let's now implement method override for each of the child object of the Shape object by providing different implementation of the ==**draw()**== method on each child object except the Circle object.\\n\\n<pre><code>\\n    function Shape(color, name){\\n        this.color = color;\\n        this.name = name;\\n    }\\n\\n    Shape.prototype.draw = function(){\\n      console.log(`${this.name} with color ${this.color} is drawn!`);\\n    };\\n\\n\\n    //Circle Shape\\n    function Circle(radius, name, color){\\n        Shape.call(this, color, name); //Calling the base or parent class\\n        this.radius = radius;\\n      }\\n\\n      //Circle inherit from Shape\\n      inherit(Shape, Circle);\\n\\n\\n    //Triangle Shape\\n    function Triangle(base, height, name, color){\\n        Shape.call(this, color, name);\\n        this.base = base;\\n        this.height = height;\\n      }\\n\\n      //Triangle inherit from Shape\\n      inherit(Shape, Triangle);\\n\\n      Triangle.prototype.draw = function(){\\n        console.log(`From Triangle override: ${this.name} with color ${this.color} is drawn!`);\\n      }\\n\\n\\n      //Rectangle Shape\\n    function Rectangle(length, breath, name, color){\\n        Shape.call(this, color, name);\\n        this.length = length;\\n        this.breath = breath;\\n      }\\n\\n        //Rectangle inherit from Shape\\n        inherit(Shape, Rectangle);\\n\\n      Rectangle.prototype.draw = function(){\\n        console.log(`From Rectangle override: ${this.name} with color ${this.color} is drawn!`);\\n      }\\n\\n\\n\\n\\n    function inherit(Parent, Child){\\n        Child.prototype = Object.create(Parent.prototype);\\n        Child.prototype.constructor = Child;\\n    }\\n\\n    const shapes = [\\n        new Circle(10, 'Circle', 'red'),\\n        new Triangle(5, 10, 'triangle', 'black'),\\n        new Rectangle(10, 10, 'rectangle', 'blue')\\n    ]\\n\\n    shapes.forEach(shape => shape.draw());\\n    //Circle with color red is drawn!\\n    //From Triangle override: triangle with color black is drawn!\\n    //From Rectangle override: rectangle with color blue is drawn!\\n</code></pre> \\n\\n\\nThe Triangle and Rectangle objects now have their own implementation of the draw method which is slightly different from their ancestor's implementation. The way this works in JavaScript is that when a method or property is invoked on an object, the property is first looked up on the object and if not found, its prototype (parent) is checked for the property and if not found, it continues to the next prototype up the chain until it's found and if eventually, it's not found, the JavaScript engine then errors out.\\n\\n\\nThis concludes the post on polymorphism in JavaScript object oriented programming\\n\\n\\nHappy coding...\\n\\n<p class=\\\"space\\\"></p>  \\n\\n\\n**__Credits:__**\\nImage by LOISLEARNS : https://loislearns.com/2016/08/30/polymorphism/\\n\\n\\n\\n\"}]],\"markups\":[],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:</p>\n<p>This series is as follows:</p>\n<ol>\n<li><a href=\"/pillars-of-objected-oriented-programming\">Pillars of Objected-Oriented Programming</a></li>\n<li><a href=\"/javascript-objects-prototype-constructor/\">JavaScript Objects, prototype, constructor, &amp; Object constructor</a></li>\n<li><a href=\"/object-creation-in-javascript/\">Object Creation in JavaScript</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-abstraction-2/\">JavaScript OOP : Abstraction</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-encapsulation/\">JavaScript OOP : Encapsulation</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-inheritance\">JavaScript OOP : Inheritance</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-polymorphism\">JavaScript OOP : Polymorphism</a></li>\n<li><a href=\"\">JavaScript OOP : Inheritance vs Composition</a></li>\n</ol>\n<p class=\"space\"></p>\n<p>This post is a continuation of the object-oriented programming in JavaScript where we discuss polymorphism.</p>\n<h3 id=\"whatispolymorphism\">What is polymorphism ?</h3>\n<p><mark><strong>Polymorphism in the ability to exist and appear in many forms</strong></mark>.</p>\n<ul>\n<li><em><mark>Derived objects or subclass may be treated as objects of a base class such as collections of arrays</mark></em></li>\n<li><em><mark>Derived objects can override methods of a base object by providing their own implementations</mark></em></li>\n</ul>\n<p>Let's explain this concepts in JavaScript while building upon the Shape object and its derived objects from the <a href=\"/pillars-of-object-oriented-programming-inheritance\">inheritance</a> post.</p>\n<blockquote>\n<p><em><p class=\"strong-point-highlight\">A Child object or subclass or derived object may be treated as a parent objects of a base class</p></em></p>\n</blockquote>\n<p>Let's borrow some code from the <a href=\"/pillars-of-object-oriented-programming-inheritance\">inheritance</a> post.</p>\n<pre><code>\n    function Shape(color, name){\n        this.color = color;\n        this.name = name;\n    }\n\n    Shape.prototype.draw = function(){\n      console.log(`${this.name} with color ${this.color} is drawn!`);\n    };\n\n\n    //Circle Shape\n    function Circle(radius, name, color){\n        //Calling the base or parent class\n        Shape.call(this, color, name);\n        this.radius = radius;\n      }\n\n      //Circle inherit from Shape\n      inherit(Shape, Circle);\n\n\n    //Triangle Shape\n    function Triangle(base, height, name, color){\n        Shape.call(this, color, name);\n        this.radius = radius;\n      }\n\n      //Triangle inherit from Shape\n      inherit(Shape, Triangle);\n\n\n      //Rectangle Shape\n    function Rectangle(length, breath, name, color){\n        Shape.call(this, color, name);\n        this.radius = radius;\n      }\n\n      //Rectangle inherit from Shape\n      inherit(Shape, Rectangle);\n\n\n    function inherit(Parent, Child){\n        Child.prototype = Object.create(Parent.prototype);\n        Child.prototype.constructor = Child;\n    }\n</code></pre> \n<p>Treating all kinds of shape as a Shape object yet still able to behave in the form of the different shapes.</p>\n<pre><code>\n    const shapes = [\n        new Circle(10, 'Circle', 'red'),\n        new Triangle(5, 10, 'triangle', 'black'),\n        new Rectangle(10, 10, 'rectangle', 'blue')\n    ]\n\n    shapes.forEach(shape => shape.draw());\n\n    //Circle with color red is drawn!\n    //triangle with color black is drawn!\n    //rectangle with color blue is drawn!\n</code></pre>  \n<p>All the shapes object are now treated like a single Shape object while they behave differently.</p>\n<p class=\"space\"></p>  \n<p class=\"space\"></p>  \n<p><em><p class=\"strong-point-highlight\">Derived objects can override methods of a base object by providing their own implementations</p></em></p>\n<p>This concept of having a child object overridding the parent's method is referred to as <mark><strong>method overriding</strong></mark>. Let's now implement method override for each of the child object of the Shape object by providing different implementation of the <mark><strong>draw()</strong></mark> method on each child object except the Circle object.</p>\n<pre><code>\n    function Shape(color, name){\n        this.color = color;\n        this.name = name;\n    }\n\n    Shape.prototype.draw = function(){\n      console.log(`${this.name} with color ${this.color} is drawn!`);\n    };\n\n\n    //Circle Shape\n    function Circle(radius, name, color){\n        Shape.call(this, color, name); //Calling the base or parent class\n        this.radius = radius;\n      }\n\n      //Circle inherit from Shape\n      inherit(Shape, Circle);\n\n\n    //Triangle Shape\n    function Triangle(base, height, name, color){\n        Shape.call(this, color, name);\n        this.base = base;\n        this.height = height;\n      }\n\n      //Triangle inherit from Shape\n      inherit(Shape, Triangle);\n\n      Triangle.prototype.draw = function(){\n        console.log(`From Triangle override: ${this.name} with color ${this.color} is drawn!`);\n      }\n\n\n      //Rectangle Shape\n    function Rectangle(length, breath, name, color){\n        Shape.call(this, color, name);\n        this.length = length;\n        this.breath = breath;\n      }\n\n        //Rectangle inherit from Shape\n        inherit(Shape, Rectangle);\n\n      Rectangle.prototype.draw = function(){\n        console.log(`From Rectangle override: ${this.name} with color ${this.color} is drawn!`);\n      }\n\n\n\n\n    function inherit(Parent, Child){\n        Child.prototype = Object.create(Parent.prototype);\n        Child.prototype.constructor = Child;\n    }\n\n    const shapes = [\n        new Circle(10, 'Circle', 'red'),\n        new Triangle(5, 10, 'triangle', 'black'),\n        new Rectangle(10, 10, 'rectangle', 'blue')\n    ]\n\n    shapes.forEach(shape => shape.draw());\n    //Circle with color red is drawn!\n    //From Triangle override: triangle with color black is drawn!\n    //From Rectangle override: rectangle with color blue is drawn!\n</code></pre> \n<p>The Triangle and Rectangle objects now have their own implementation of the draw method which is slightly different from their ancestor's implementation. The way this works in JavaScript is that when a method or property is invoked on an object, the property is first looked up on the object and if not found, its prototype (parent) is checked for the property and if not found, it continues to the next prototype up the chain until it's found and if eventually, it's not found, the JavaScript engine then errors out.</p>\n<p>This concludes the post on polymorphism in JavaScript object oriented programming</p>\n<p>Happy coding...</p>\n<p class=\"space\"></p>  \n<p><strong><strong>Credits:</strong></strong><br>\nImage by LOISLEARNS : <a href=\"https://loislearns.com/2016/08/30/polymorphism/\">https://loislearns.com/2016/08/30/polymorphism/</a></p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5ae56a37d8240f1f647a63ce",
    "plaintext": "This post is part of a series of posts on JavaScript object-oriented\nprogramming. Link to the series are as follows:\n\nThis series is as follows:\n\n 1. Pillars of Objected-Oriented Programming\n    [/pillars-of-objected-oriented-programming]\n 2. JavaScript Objects, prototype, constructor, & Object constructor\n    [/javascript-objects-prototype-constructor/]\n 3. Object Creation in JavaScript [/object-creation-in-javascript/]\n 4. JavaScript OOP : Abstraction\n    [/pillars-of-object-oriented-programming-abstraction-2/]\n 5. JavaScript OOP : Encapsulation\n    [/pillars-of-object-oriented-programming-encapsulation/]\n 6. JavaScript OOP : Inheritance\n    [/pillars-of-object-oriented-programming-inheritance]\n 7. JavaScript OOP : Polymorphism\n    [/pillars-of-object-oriented-programming-polymorphism]\n 8. JavaScript OOP : Inheritance vs Composition\n\n\n\nThis post is a continuation of the object-oriented programming in JavaScript\nwhere we discuss polymorphism.\n\nWhat is polymorphism ?\nPolymorphism in the ability to exist and appear in many forms.\n\n * Derived objects or subclass may be treated as objects of a base class such as\n   collections of arrays\n * Derived objects can override methods of a base object by providing their own\n   implementations\n\nLet's explain this concepts in JavaScript while building upon the Shape object\nand its derived objects from the inheritance\n[/pillars-of-object-oriented-programming-inheritance] post.\n\n> A Child object or subclass or derived object may be treated as a parent objects\nof a base class\n\n\n\n\nLet's borrow some code from the inheritance\n[/pillars-of-object-oriented-programming-inheritance] post.\n\n\n    function Shape(color, name){\n        this.color = color;\n        this.name = name;\n    }\n\n    Shape.prototype.draw = function(){\n      console.log(`${this.name} with color ${this.color} is drawn!`);\n    };\n\n\n    //Circle Shape\n    function Circle(radius, name, color){\n        //Calling the base or parent class\n        Shape.call(this, color, name);\n        this.radius = radius;\n      }\n\n      //Circle inherit from Shape\n      inherit(Shape, Circle);\n\n\n    //Triangle Shape\n    function Triangle(base, height, name, color){\n        Shape.call(this, color, name);\n        this.radius = radius;\n      }\n\n      //Triangle inherit from Shape\n      inherit(Shape, Triangle);\n\n\n      //Rectangle Shape\n    function Rectangle(length, breath, name, color){\n        Shape.call(this, color, name);\n        this.radius = radius;\n      }\n\n      //Rectangle inherit from Shape\n      inherit(Shape, Rectangle);\n\n\n    function inherit(Parent, Child){\n        Child.prototype = Object.create(Parent.prototype);\n        Child.prototype.constructor = Child;\n    }\n\n\nTreating all kinds of shape as a Shape object yet still able to behave in the\nform of the different shapes.\n\n\n    const shapes = [\n        new Circle(10, 'Circle', 'red'),\n        new Triangle(5, 10, 'triangle', 'black'),\n        new Rectangle(10, 10, 'rectangle', 'blue')\n    ]\n\n    shapes.forEach(shape => shape.draw());\n\n    //Circle with color red is drawn!\n    //triangle with color black is drawn!\n    //rectangle with color blue is drawn!\n\n\nAll the shapes object are now treated like a single Shape object while they\nbehave differently.\n\n\n\n\n\nDerived objects can override methods of a base object by providing their own\nimplementations\n\n\n\nThis concept of having a child object overridding the parent's method is\nreferred to as method overriding. Let's now implement method override for each\nof the child object of the Shape object by providing different implementation of\nthe draw() method on each child object except the Circle object.\n\n\n    function Shape(color, name){\n        this.color = color;\n        this.name = name;\n    }\n\n    Shape.prototype.draw = function(){\n      console.log(`${this.name} with color ${this.color} is drawn!`);\n    };\n\n\n    //Circle Shape\n    function Circle(radius, name, color){\n        Shape.call(this, color, name); //Calling the base or parent class\n        this.radius = radius;\n      }\n\n      //Circle inherit from Shape\n      inherit(Shape, Circle);\n\n\n    //Triangle Shape\n    function Triangle(base, height, name, color){\n        Shape.call(this, color, name);\n        this.base = base;\n        this.height = height;\n      }\n\n      //Triangle inherit from Shape\n      inherit(Shape, Triangle);\n\n      Triangle.prototype.draw = function(){\n        console.log(`From Triangle override: ${this.name} with color ${this.color} is drawn!`);\n      }\n\n\n      //Rectangle Shape\n    function Rectangle(length, breath, name, color){\n        Shape.call(this, color, name);\n        this.length = length;\n        this.breath = breath;\n      }\n\n        //Rectangle inherit from Shape\n        inherit(Shape, Rectangle);\n\n      Rectangle.prototype.draw = function(){\n        console.log(`From Rectangle override: ${this.name} with color ${this.color} is drawn!`);\n      }\n\n\n\n\n    function inherit(Parent, Child){\n        Child.prototype = Object.create(Parent.prototype);\n        Child.prototype.constructor = Child;\n    }\n\n    const shapes = [\n        new Circle(10, 'Circle', 'red'),\n        new Triangle(5, 10, 'triangle', 'black'),\n        new Rectangle(10, 10, 'rectangle', 'blue')\n    ]\n\n    shapes.forEach(shape => shape.draw());\n    //Circle with color red is drawn!\n    //From Triangle override: triangle with color black is drawn!\n    //From Rectangle override: rectangle with color blue is drawn!\n\n\nThe Triangle and Rectangle objects now have their own implementation of the draw\nmethod which is slightly different from their ancestor's implementation. The way\nthis works in JavaScript is that when a method or property is invoked on an\nobject, the property is first looked up on the object and if not found, its\nprototype (parent) is checked for the property and if not found, it continues to\nthe next prototype up the chain until it's found and if eventually, it's not\nfound, the JavaScript engine then errors out.\n\nThis concludes the post on polymorphism in JavaScript object oriented\nprogramming\n\nHappy coding...\n\n\n\nCredits:\nImage by LOISLEARNS : https://loislearns.com/2016/08/30/polymorphism/",
    "feature_image": "https://images.unsplash.com/photo-1562065540-efa93744ed71?ixlib=rb-1.2.1&q=80&fm=jpg&crop=entropy&cs=tinysrgb&w=1080&fit=max&ixid=eyJhcHBfaWQiOjExNzczfQ",
    "featured": 0,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-29 06:46:15",
    "updated_at": "2019-07-02 20:21:17",
    "published_at": "2018-07-27 02:29:30",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7ed",
    "uuid": "6a09cb23-8d89-4486-9022-78c58501ac70",
    "title": "JavaScript OOP : Abstraction",
    "slug": "pillars-of-object-oriented-programming-abstraction-2",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:  \\n\\nThis series is as follows:\\n\\n1.  [Pillars of Objected-Oriented Programming](/pillars-of-objected-oriented-programming)\\n2. [JavaScript Objects, prototype, constructor, & Object constructor](/javascript-objects-prototype-constructor/)\\n3. [Object Creation in JavaScript](/object-creation-in-javascript/)\\n4. [JavaScript OOP : Abstraction](/pillars-of-object-oriented-programming-abstraction-2/)\\n5. [JavaScript OOP : Encapsulation](/pillars-of-object-oriented-programming-encapsulation/)\\n6. [JavaScript OOP : Inheritance](/pillars-of-object-oriented-programming-inheritance)\\n7. [JavaScript OOP : Polymorphism](/pillars-of-object-oriented-programming-polymorphism)\\n8. [JavaScript OOP : Inheritance vs Composition]()\\n\\n\\nLet's get to the fun part, see how we can implement abstraction in JavaScript. As a reminder, abstraction is the process of hiding away implementation and internal details and present the user with what's needed. We are going to focus on the cassette player we used in the previous post on abstraction. Remember this?\\n\\n![Casset player](https://images.unsplash.com/photo-1495369470453-f6af4ade471b?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=1b9c2148b9404faac82511c12524ffe7&auto=format&fit=crop&w=600&q=80&style=center)\\n\\nLet's now represent our cassette player as an object by abstracting away the internal implementation:\\n\\n<pre><code>\\n    function CassettePlayer(cassette){\\n      this.cassette = cassette;\\n\\n      this.play = function(){\\n        console.log(`I am playing ${this.cassette}`);\\n      };\\n      \\n      this.pause = function(){\\n        //pause cassette\\n      }\\n\\n      this.stop = function(){\\n        //stop playing\\n      };\\n\\n      this.record = function(){\\n        //record onto a cassette\\n      };\\n\\n      this.forward = function(){\\n        //forward cassette\\n      };\\n\\n      this.rewind = function(){\\n        //rewind cassette\\n      };\\n\\n      this.eject = function(){\\n        //eject cassette\\n      };\\n    }\\n</code></pre>\\n\\nNow as we have abstracted the CassetPlayer object and do not care about its implementation details. All a user cares about is to play, pause, stop, rewind, forward, record, and eject using the CassettePlayer. \\n\\nThis is abstraction. Present the user or consumer of an object with only what it needs. Keep it simple. There's a small issue which am going to point out and solve it using __encapsulation__.\\n\\nWe may now call the CassettePlayer object to play a cassette:\\n\\n<pre><code>let cassetPlayer = new CassettePlayer(\\\"Hip-hop\\\");\\ncassetPlayer.play() // I am playing Hip-hop\\n</code></pre>\\n\\nVisualising the CassettePlayer's property:\\n\\n![abstraction](https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2Fimage.png?v=1562526047200)\\n\\nThe issue of the CassettePlayer's internal property, *cassette* leaking to the outside shall be taken care of by implementing __encapsulation__ which we'll look at next.\\n\\n\\nHappy coding.\\n\"}]],\"markups\":[],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>This post is part of a series of posts on JavaScript object-oriented programming. Link to the series are as follows:</p>\n<p>This series is as follows:</p>\n<ol>\n<li><a href=\"/pillars-of-objected-oriented-programming\">Pillars of Objected-Oriented Programming</a></li>\n<li><a href=\"/javascript-objects-prototype-constructor/\">JavaScript Objects, prototype, constructor, &amp; Object constructor</a></li>\n<li><a href=\"/object-creation-in-javascript/\">Object Creation in JavaScript</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-abstraction-2/\">JavaScript OOP : Abstraction</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-encapsulation/\">JavaScript OOP : Encapsulation</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-inheritance\">JavaScript OOP : Inheritance</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-polymorphism\">JavaScript OOP : Polymorphism</a></li>\n<li><a href=\"\">JavaScript OOP : Inheritance vs Composition</a></li>\n</ol>\n<p>Let's get to the fun part, see how we can implement abstraction in JavaScript. As a reminder, abstraction is the process of hiding away implementation and internal details and present the user with what's needed. We are going to focus on the cassette player we used in the previous post on abstraction. Remember this?</p>\n<p><img src=\"https://images.unsplash.com/photo-1495369470453-f6af4ade471b?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=1b9c2148b9404faac82511c12524ffe7&amp;auto=format&amp;fit=crop&amp;w=600&amp;q=80&amp;style=center\" alt=\"Casset player\"></p>\n<p>Let's now represent our cassette player as an object by abstracting away the internal implementation:</p>\n<pre><code>\n    function CassettePlayer(cassette){\n      this.cassette = cassette;\n\n      this.play = function(){\n        console.log(`I am playing ${this.cassette}`);\n      };\n      \n      this.pause = function(){\n        //pause cassette\n      }\n\n      this.stop = function(){\n        //stop playing\n      };\n\n      this.record = function(){\n        //record onto a cassette\n      };\n\n      this.forward = function(){\n        //forward cassette\n      };\n\n      this.rewind = function(){\n        //rewind cassette\n      };\n\n      this.eject = function(){\n        //eject cassette\n      };\n    }\n</code></pre>\n<p>Now as we have abstracted the CassetPlayer object and do not care about its implementation details. All a user cares about is to play, pause, stop, rewind, forward, record, and eject using the CassettePlayer.</p>\n<p>This is abstraction. Present the user or consumer of an object with only what it needs. Keep it simple. There's a small issue which am going to point out and solve it using <strong>encapsulation</strong>.</p>\n<p>We may now call the CassettePlayer object to play a cassette:</p>\n<pre><code>let cassetPlayer = new CassettePlayer(\"Hip-hop\");\ncassetPlayer.play() // I am playing Hip-hop\n</code></pre>\n<p>Visualising the CassettePlayer's property:</p>\n<p><img src=\"https://cdn.glitch.com/5694ae69-e1a8-4701-a18f-ad933f1baa0c%2Fimage.png?v=1562526047200\" alt=\"abstraction\"></p>\n<p>The issue of the CassettePlayer's internal property, <em>cassette</em> leaking to the outside shall be taken care of by implementing <strong>encapsulation</strong> which we'll look at next.</p>\n<p>Happy coding.</p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5ae56a44d8240f1f647a63d0",
    "plaintext": "This post is part of a series of posts on JavaScript object-oriented\nprogramming. Link to the series are as follows:\n\nThis series is as follows:\n\n 1. Pillars of Objected-Oriented Programming\n    [/pillars-of-objected-oriented-programming]\n 2. JavaScript Objects, prototype, constructor, & Object constructor\n    [/javascript-objects-prototype-constructor/]\n 3. Object Creation in JavaScript [/object-creation-in-javascript/]\n 4. JavaScript OOP : Abstraction\n    [/pillars-of-object-oriented-programming-abstraction-2/]\n 5. JavaScript OOP : Encapsulation\n    [/pillars-of-object-oriented-programming-encapsulation/]\n 6. JavaScript OOP : Inheritance\n    [/pillars-of-object-oriented-programming-inheritance]\n 7. JavaScript OOP : Polymorphism\n    [/pillars-of-object-oriented-programming-polymorphism]\n 8. JavaScript OOP : Inheritance vs Composition\n\nLet's get to the fun part, see how we can implement abstraction in JavaScript.\nAs a reminder, abstraction is the process of hiding away implementation and\ninternal details and present the user with what's needed. We are going to focus\non the cassette player we used in the previous post on abstraction. Remember\nthis?\n\n\n\nLet's now represent our cassette player as an object by abstracting away the\ninternal implementation:\n\n\n    function CassettePlayer(cassette){\n      this.cassette = cassette;\n\n      this.play = function(){\n        console.log(`I am playing ${this.cassette}`);\n      };\n      \n      this.pause = function(){\n        //pause cassette\n      }\n\n      this.stop = function(){\n        //stop playing\n      };\n\n      this.record = function(){\n        //record onto a cassette\n      };\n\n      this.forward = function(){\n        //forward cassette\n      };\n\n      this.rewind = function(){\n        //rewind cassette\n      };\n\n      this.eject = function(){\n        //eject cassette\n      };\n    }\n\n\nNow as we have abstracted the CassetPlayer object and do not care about its\nimplementation details. All a user cares about is to play, pause, stop, rewind,\nforward, record, and eject using the CassettePlayer.\n\nThis is abstraction. Present the user or consumer of an object with only what it\nneeds. Keep it simple. There's a small issue which am going to point out and\nsolve it using encapsulation.\n\nWe may now call the CassettePlayer object to play a cassette:\n\nlet cassetPlayer = new CassettePlayer(\"Hip-hop\");\ncassetPlayer.play() // I am playing Hip-hop\n\n\nVisualising the CassettePlayer's property:\n\n\n\nThe issue of the CassettePlayer's internal property, cassette leaking to the\noutside shall be taken care of by implementing encapsulation which we'll look at\nnext.\n\nHappy coding.",
    "feature_image": null,
    "featured": 0,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-29 06:46:28",
    "updated_at": "2019-07-07 19:08:39",
    "published_at": "2018-05-03 11:00:00",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7ee",
    "uuid": "3939985a-8e46-453f-ad9a-afe7daf18608",
    "title": "Object-Oriented JavaScript",
    "slug": "javascript-object-oriented-programming-introduction",
    "mobiledoc": "{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"card-markdown\",{\"cardName\":\"card-markdown\",\"markdown\":\"For a while, the concept of OOP in Javascript bewildered me that I tried on several occasions to avoid it in the past. Avoiding it didn't help, it kept haunting me everywhere I turned as a software developer. Having been in such position, I will help you demystify Object Oriented Programming in JavaScript, and you will never be scared again just like I was.  \\n\\nThis post will be divided up into mini-series to help us keep things light, easy to grasp and remember.  These series assume you have some knowledge of Javascript and you want to understand how OOP works in JavaScript.\\n\\nThis series is as follows:\\n\\n1.  [Pillars of Objected-Oriented Programming](/pillars-of-objected-oriented-programming)\\n2. [JavaScript Objects, prototype, constructor, & Object constructor](/javascript-objects-prototype-constructor/)\\n3. [Object Creation in JavaScript](/object-creation-in-javascript/)\\n4. [JavaScript OOP : Abstraction](/pillars-of-object-oriented-programming-abstraction-2/)\\n5. [JavaScript OOP : Encapsulation](/pillars-of-object-oriented-programming-encapsulation/)\\n6. [JavaScript OOP : Inheritance](/pillars-of-object-oriented-programming-inheritance)\\n7. [JavaScript OOP : Polymorphism](/pillars-of-object-oriented-programming-polymorphism)\\n8. [JavaScript OOP : Inheritance vs Composition]()\\n\\n\\nWe now have our content structure to follow, let's get started here: [Pillars of Objected-Oriented Programming](/pillars-of-objected-oriented-programming/)\"}]],\"sections\":[[10,0]]}",
    "html": "<!--kg-card-begin: markdown--><p>For a while, the concept of OOP in Javascript bewildered me that I tried on several occasions to avoid it in the past. Avoiding it didn't help, it kept haunting me everywhere I turned as a software developer. Having been in such position, I will help you demystify Object Oriented Programming in JavaScript, and you will never be scared again just like I was.</p>\n<p>This post will be divided up into mini-series to help us keep things light, easy to grasp and remember.  These series assume you have some knowledge of Javascript and you want to understand how OOP works in JavaScript.</p>\n<p>This series is as follows:</p>\n<ol>\n<li><a href=\"/pillars-of-objected-oriented-programming\">Pillars of Objected-Oriented Programming</a></li>\n<li><a href=\"/javascript-objects-prototype-constructor/\">JavaScript Objects, prototype, constructor, &amp; Object constructor</a></li>\n<li><a href=\"/object-creation-in-javascript/\">Object Creation in JavaScript</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-abstraction-2/\">JavaScript OOP : Abstraction</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-encapsulation/\">JavaScript OOP : Encapsulation</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-inheritance\">JavaScript OOP : Inheritance</a></li>\n<li><a href=\"/pillars-of-object-oriented-programming-polymorphism\">JavaScript OOP : Polymorphism</a></li>\n<li><a href=\"\">JavaScript OOP : Inheritance vs Composition</a></li>\n</ol>\n<p>We now have our content structure to follow, let's get started here: <a href=\"/pillars-of-objected-oriented-programming/\">Pillars of Objected-Oriented Programming</a></p>\n<!--kg-card-end: markdown-->",
    "comment_id": "5ae572d9d8240f1f647a63dc",
    "plaintext": "For a while, the concept of OOP in Javascript bewildered me that I tried on\nseveral occasions to avoid it in the past. Avoiding it didn't help, it kept\nhaunting me everywhere I turned as a software developer. Having been in such\nposition, I will help you demystify Object Oriented Programming in JavaScript,\nand you will never be scared again just like I was.\n\nThis post will be divided up into mini-series to help us keep things light, easy\nto grasp and remember. These series assume you have some knowledge of Javascript\nand you want to understand how OOP works in JavaScript.\n\nThis series is as follows:\n\n 1. Pillars of Objected-Oriented Programming\n    [/pillars-of-objected-oriented-programming]\n 2. JavaScript Objects, prototype, constructor, & Object constructor\n    [/javascript-objects-prototype-constructor/]\n 3. Object Creation in JavaScript [/object-creation-in-javascript/]\n 4. JavaScript OOP : Abstraction\n    [/pillars-of-object-oriented-programming-abstraction-2/]\n 5. JavaScript OOP : Encapsulation\n    [/pillars-of-object-oriented-programming-encapsulation/]\n 6. JavaScript OOP : Inheritance\n    [/pillars-of-object-oriented-programming-inheritance]\n 7. JavaScript OOP : Polymorphism\n    [/pillars-of-object-oriented-programming-polymorphism]\n 8. JavaScript OOP : Inheritance vs Composition\n\nWe now have our content structure to follow, let's get started here: Pillars of\nObjected-Oriented Programming [/pillars-of-objected-oriented-programming/]",
    "feature_image": "/content/images/2019/07/javascriptoop.png",
    "featured": 1,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2018-04-29 07:23:05",
    "updated_at": "2019-07-07 20:10:16",
    "published_at": "2018-04-29 07:23:54",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7ef",
    "uuid": "ff7bba55-f89a-44c6-a37b-48b4364f66ce",
    "title": "Call, Apply & Bind",
    "slug": "untitled-call-apply",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"code\",{\"code\":\"    //object A\\n    let A = {\\n        name: \\\"Michael\\\",\\n        lastName: \\\"Programmer\\\",\\n        getFullName(){\\n            console.log(`The full name is ${this.name} ${this.lastName}`)\\n        }\\n    }\",\"language\":\"javascript\",\"caption\":\"\"}],[\"code\",{\"code\":\"    //object B\\n    let B = {\\n        name: \\\"Another\\\",\\n        lastName: \\\"Michael\\\"\\n    }\",\"caption\":\"\",\"language\":\"javascript\"}],[\"markdown\",{\"markdown\":\"\\n### Borrowing\\nNow let's borrow the getFullName method of object A to output to the console details of object B\"}],[\"code\",{\"language\":\"javascript\",\"code\":\"A.getFullName.call(B); // The full name is Another Michael\"}],[\"code\",{\"language\":\"javascript\",\"code\":\"    let namePrinter = function(){\\n        console.log(`The full name is ${this.name} ${this.lastName}`);\\n    };\\n\\n\\t//object A\\n    let A = {\\n        name: \\\"Michael\\\",\\n        lastName: \\\"Programmer\\\"\\n    }\\n    \\n    //object B\\n    let B = {\\n        name: \\\"Another\\\",\\n        lastName: \\\"Michael\\\"\\n    };\\n    \\n    namePrinter.call(A); //The full name is Michael Programmer\\n    namePrinter.call(B); //The full name is Another Michael\"}],[\"code\",{\"language\":\"javascript\",\"code\":\"    let namePrinterWithHomeTown = function (hometown) {\\n      console.log(`${this.name} ${this.lastName} is from ${hometown}`);\\n    }\\n    \\n    //object C\\n    let C = {\\n      name: \\\"Jack\\\",\\n      lastName: \\\"Black\\\"\\n    };\\n\\n    //object D\\n    let D = {\\n      name: \\\"Alaka\\\",\\n      lastName: \\\"Kamba\\\"\\n    };\\n\\n    namePrinterWithHomeTown.call(A, \\\"Serbia\\\") // Michael Programmer is from Serbia\"}],[\"code\",{\"language\":\"javascript\",\"code\":\"    namePrinter.apply(C) //The first name is Jack, last name is Black\"}],[\"code\",{\"language\":\"javascript\",\"code\":\"    namePrinterWithHomeTown.apply(C, [\\\"Madagascar\\\"]) //Jack Black is from Madagascar\"}],[\"code\",{\"language\":\"javascript\",\"code\":\"    let objD = namePrinter.bind(D); \\n    objD(); // The first name is Alaka, last name is Kamba\"}],[\"code\",{\"language\":\"javascript\",\"code\":\"    let nameCountry = namePrinterWithHomeTown.bind(C, \\\"Peru\\\");\\n    nameCountry(); // Jack Black is from Peru\"}],[\"embed\",{\"url\":\"https://stackblitz.com/edit/bind-call-apply?file=index.js\",\"html\":\"<iframe src=\\\"https://stackblitz.com/edit/bind-call-apply?embed=1&amp;file=index.js\\\" height=\\\"400\\\" width=\\\"745\\\"></iframe>\",\"type\":\"rich\"}]],\"markups\":[[\"strong\"],[\"em\"]],\"sections\":[[1,\"p\",[[0,[],0,\"In this blog post, I will quickly discuss the \"],[0,[0],1,\"call()\"],[0,[],0,\", \"],[0,[0],1,\"apply()\"],[0,[],0,\" & \"],[0,[0],1,\"bind()\"],[0,[],0,\" methods. These methods allows for dynamic change in the JavaScript \\\"\"],[0,[1],1,\"this\"],[0,[],0,\"\\\". The \"],[0,[1],1,\"this \"],[0,[],0,\"can be changed depending on the context being used. The usefulness of these methods comes when you want to do some method or function borrowing. Without further due, let's master this methods with examples.\"]]],[1,\"blockquote\",[[0,[],0,\"The call(), apply(), and bind() method all do the same thing with some slight variation.\"]]],[1,\"p\",[[0,[1],1,\"Method borrowing\"],[0,[],0,\" in JavaScript is the concept of reusing an exiting method within the context of different object or reuse method outside the context with which it was created.\"]]],[1,\"blockquote\",[[0,[],0,\"Say object A has a method \"],[0,[1],1,\"f, object \"],[0,[],0,\"B should be able to use method \"],[0,[1],1,\"f \"],[0,[],0,\"of A if the same property(ies) are present in both object.\"]]],[1,\"p\",[[0,[],0,\"Let's illustrate this concept in code. \"]]],[1,\"p\",[[0,[],0,\"Let's say objects A and B\"]]],[10,0],[10,1],[10,2],[1,\"p\",[]],[1,\"h5\",[[0,[1],1,\"Call() method\"]]],[1,\"blockquote\",[[0,[],0,\"call(thisArg: any, arg1, arg2...argn)\"]]],[1,\"p\",[[0,[],0,\"The call method accepts an argument list separated by commas. The first argument references the \"],[0,[1],1,\"this\"],[0,[],0,\" keyword, which is the object you are trying to switch context to. In the example below, object B is \"],[0,[1],1,\"this\"]]],[10,3],[1,\"p\",[[0,[],0,\"Boom! that simple.\"]]],[1,\"p\",[[0,[],0,\"We could also rip out the method from the object A and have object A and object B borrow and use the function.\"]]],[10,4],[1,\"p\",[]],[1,\"p\",[[0,[1],1,\"Passing argument\"]]],[1,\"p\",[[0,[],0,\"In case you are wondering, we can also pass arguments let see this with an example. Suppose the namePrinter function also accepts and output a country. You can pass in the argument after referencing \"],[0,[1],1,\"this. \"],[0,[],0,\"Let's create another function accepting an argument and let's borrow it. Let's also add objects C and D.\"]]],[10,5],[1,\"p\",[]],[1,\"h5\",[[0,[1],1,\"Apply() method\"]]],[1,\"blockquote\",[[0,[],0,\"apply(thisArg: [args])\"]]],[1,\"p\",[[0,[],0,\"The apply method works the exact same way as the call method but it accepts an array of argument after referencing \"],[0,[1],1,\"this.\"]]],[10,6],[1,\"p\",[[0,[1],1,\"Passing arguments\"]]],[10,7],[1,\"h5\",[[0,[1],1,\"Bind() method\"]]],[1,\"blockquote\",[[0,[],0,\"bind(thisArg, Args)\"]]],[1,\"p\",[[0,[],0,\"Bind behaves very similar to apply and call method with the only difference being bind is deferred which means it has to be manually invoked because it's not invoked automatically like \"],[0,[1],1,\"call \"],[0,[],0,\" and \"],[0,[1],1,\"apply\"],[0,[],0,\". Let see this in code.\"]]],[10,8],[1,\"p\",[[0,[1],1,\"Passing argument\"]]],[10,9],[1,\"p\",[[0,[],0,\"A great benefit of these methods is \"],[0,[0,1],2,\"reusability\"],[0,[],0,\". If you have multiple object having same or very similar shape, and you want to carry out a common operation across these objects, you can function borrow if you are not using prototypical inheritance.\"]]],[1,\"p\",[[0,[],0,\"Throughout the javascript ecosystem, the \"],[0,[1],1,\"call, bind, & apply \"],[0,[],0,\"method can be used with almost anything in terms or attaching and switching contexts. Below is a playground to play around with these methods. Open up the console at the bottom right to see results. \"]]],[1,\"p\",[[0,[],0,\"I will explore some advance application of these methods in another post which will go in-depth to explain some powerful concepts.\"]]],[1,\"p\",[[0,[],0,\"Happy Coding!\"]]],[10,10],[1,\"p\",[]]]}",
    "html": "<p>In this blog post, I will quickly discuss the <strong>call()</strong>, <strong>apply()</strong> &amp; <strong>bind()</strong> methods. These methods allows for dynamic change in the JavaScript \"<em>this</em>\". The <em>this </em>can be changed depending on the context being used. The usefulness of these methods comes when you want to do some method or function borrowing. Without further due, let's master this methods with examples.</p><blockquote>The call(), apply(), and bind() method all do the same thing with some slight variation.</blockquote><p><em>Method borrowing</em> in JavaScript is the concept of reusing an exiting method within the context of different object or reuse method outside the context with which it was created.</p><blockquote>Say object A has a method <em>f, object </em>B should be able to use method <em>f </em>of A if the same property(ies) are present in both object.</blockquote><p>Let's illustrate this concept in code. </p><p>Let's say objects A and B</p><pre><code class=\"language-javascript\">    //object A\n    let A = {\n        name: \"Michael\",\n        lastName: \"Programmer\",\n        getFullName(){\n            console.log(`The full name is ${this.name} ${this.lastName}`)\n        }\n    }</code></pre><pre><code class=\"language-javascript\">    //object B\n    let B = {\n        name: \"Another\",\n        lastName: \"Michael\"\n    }</code></pre><!--kg-card-begin: markdown--><h3 id=\"borrowing\">Borrowing</h3>\n<p>Now let's borrow the getFullName method of object A to output to the console details of object B</p>\n<!--kg-card-end: markdown--><p></p><h5 id=\"call-method\"><em>Call() method</em></h5><blockquote>call(thisArg: any, arg1, arg2...argn)</blockquote><p>The call method accepts an argument list separated by commas. The first argument references the <em>this</em> keyword, which is the object you are trying to switch context to. In the example below, object B is <em>this</em></p><pre><code class=\"language-javascript\">A.getFullName.call(B); // The full name is Another Michael</code></pre><p>Boom! that simple.</p><p>We could also rip out the method from the object A and have object A and object B borrow and use the function.</p><pre><code class=\"language-javascript\">    let namePrinter = function(){\n        console.log(`The full name is ${this.name} ${this.lastName}`);\n    };\n\n\t//object A\n    let A = {\n        name: \"Michael\",\n        lastName: \"Programmer\"\n    }\n    \n    //object B\n    let B = {\n        name: \"Another\",\n        lastName: \"Michael\"\n    };\n    \n    namePrinter.call(A); //The full name is Michael Programmer\n    namePrinter.call(B); //The full name is Another Michael</code></pre><p></p><p><em>Passing argument</em></p><p>In case you are wondering, we can also pass arguments let see this with an example. Suppose the namePrinter function also accepts and output a country. You can pass in the argument after referencing <em>this. </em>Let's create another function accepting an argument and let's borrow it. Let's also add objects C and D.</p><pre><code class=\"language-javascript\">    let namePrinterWithHomeTown = function (hometown) {\n      console.log(`${this.name} ${this.lastName} is from ${hometown}`);\n    }\n    \n    //object C\n    let C = {\n      name: \"Jack\",\n      lastName: \"Black\"\n    };\n\n    //object D\n    let D = {\n      name: \"Alaka\",\n      lastName: \"Kamba\"\n    };\n\n    namePrinterWithHomeTown.call(A, \"Serbia\") // Michael Programmer is from Serbia</code></pre><p></p><h5 id=\"apply-method\"><em>Apply() method</em></h5><blockquote>apply(thisArg: [args])</blockquote><p>The apply method works the exact same way as the call method but it accepts an array of argument after referencing <em>this.</em></p><pre><code class=\"language-javascript\">    namePrinter.apply(C) //The first name is Jack, last name is Black</code></pre><p><em>Passing arguments</em></p><pre><code class=\"language-javascript\">    namePrinterWithHomeTown.apply(C, [\"Madagascar\"]) //Jack Black is from Madagascar</code></pre><h5 id=\"bind-method\"><em>Bind() method</em></h5><blockquote>bind(thisArg, Args)</blockquote><p>Bind behaves very similar to apply and call method with the only difference being bind is deferred which means it has to be manually invoked because it's not invoked automatically like <em>call </em> and <em>apply</em>. Let see this in code.</p><pre><code class=\"language-javascript\">    let objD = namePrinter.bind(D); \n    objD(); // The first name is Alaka, last name is Kamba</code></pre><p><em>Passing argument</em></p><pre><code class=\"language-javascript\">    let nameCountry = namePrinterWithHomeTown.bind(C, \"Peru\");\n    nameCountry(); // Jack Black is from Peru</code></pre><p>A great benefit of these methods is <strong><em>reusability</em></strong>. If you have multiple object having same or very similar shape, and you want to carry out a common operation across these objects, you can function borrow if you are not using prototypical inheritance.</p><p>Throughout the javascript ecosystem, the <em>call, bind, &amp; apply </em>method can be used with almost anything in terms or attaching and switching contexts. Below is a playground to play around with these methods. Open up the console at the bottom right to see results. </p><p>I will explore some advance application of these methods in another post which will go in-depth to explain some powerful concepts.</p><p>Happy Coding!</p><figure class=\"kg-card kg-embed-card\"><iframe src=\"https://stackblitz.com/edit/bind-call-apply?embed=1&amp;file=index.js\" height=\"400\" width=\"745\"></iframe></figure>",
    "comment_id": "5d1b8ebaa38224549403f719",
    "plaintext": "In this blog post, I will quickly discuss the call(), apply() & bind() methods.\nThese methods allows for dynamic change in the JavaScript \"this\". The this can\nbe changed depending on the context being used. The usefulness of these methods\ncomes when you want to do some method or function borrowing. Without further\ndue, let's master this methods with examples.\n\n> The call(), apply(), and bind() method all do the same thing with some slight\nvariation.\nMethod borrowing in JavaScript is the concept of reusing an exiting method\nwithin the context of different object or reuse method outside the context with\nwhich it was created.\n\n> Say object A has a method f, object B should be able to use method f of A if the\nsame property(ies) are present in both object.\nLet's illustrate this concept in code. \n\nLet's say objects A and B\n\n    //object A\n    let A = {\n        name: \"Michael\",\n        lastName: \"Programmer\",\n        getFullName(){\n            console.log(`The full name is ${this.name} ${this.lastName}`)\n        }\n    }\n\n    //object B\n    let B = {\n        name: \"Another\",\n        lastName: \"Michael\"\n    }\n\nBorrowing\nNow let's borrow the getFullName method of object A to output to the console\ndetails of object B\n\n\n\nCall() method\n> call(thisArg: any, arg1, arg2...argn)\nThe call method accepts an argument list separated by commas. The first argument\nreferences the this keyword, which is the object you are trying to switch\ncontext to. In the example below, object B is this\n\nA.getFullName.call(B); // The full name is Another Michael\n\nBoom! that simple.\n\nWe could also rip out the method from the object A and have object A and object\nB borrow and use the function.\n\n    let namePrinter = function(){\n        console.log(`The full name is ${this.name} ${this.lastName}`);\n    };\n\n\t//object A\n    let A = {\n        name: \"Michael\",\n        lastName: \"Programmer\"\n    }\n    \n    //object B\n    let B = {\n        name: \"Another\",\n        lastName: \"Michael\"\n    };\n    \n    namePrinter.call(A); //The full name is Michael Programmer\n    namePrinter.call(B); //The full name is Another Michael\n\n\n\nPassing argument\n\nIn case you are wondering, we can also pass arguments let see this with an\nexample. Suppose the namePrinter function also accepts and output a country. You\ncan pass in the argument after referencing this. Let's create another function\naccepting an argument and let's borrow it. Let's also add objects C and D.\n\n    let namePrinterWithHomeTown = function (hometown) {\n      console.log(`${this.name} ${this.lastName} is from ${hometown}`);\n    }\n    \n    //object C\n    let C = {\n      name: \"Jack\",\n      lastName: \"Black\"\n    };\n\n    //object D\n    let D = {\n      name: \"Alaka\",\n      lastName: \"Kamba\"\n    };\n\n    namePrinterWithHomeTown.call(A, \"Serbia\") // Michael Programmer is from Serbia\n\n\n\nApply() method\n> apply(thisArg: [args])\nThe apply method works the exact same way as the call method but it accepts an\narray of argument after referencing this.\n\n    namePrinter.apply(C) //The first name is Jack, last name is Black\n\nPassing arguments\n\n    namePrinterWithHomeTown.apply(C, [\"Madagascar\"]) //Jack Black is from Madagascar\n\nBind() method\n> bind(thisArg, Args)\nBind behaves very similar to apply and call method with the only difference\nbeing bind is deferred which means it has to be manually invoked because it's\nnot invoked automatically like call and apply. Let see this in code.\n\n    let objD = namePrinter.bind(D); \n    objD(); // The first name is Alaka, last name is Kamba\n\nPassing argument\n\n    let nameCountry = namePrinterWithHomeTown.bind(C, \"Peru\");\n    nameCountry(); // Jack Black is from Peru\n\nA great benefit of these methods is reusability. If you have multiple object\nhaving same or very similar shape, and you want to carry out a common operation\nacross these objects, you can function borrow if you are not using prototypical\ninheritance.\n\nThroughout the javascript ecosystem, the call, bind, & apply method can be used\nwith almost anything in terms or attaching and switching contexts. Below is a\nplayground to play around with these methods. Open up the console at the bottom\nright to see results. \n\nI will explore some advance application of these methods in another post which\nwill go in-depth to explain some powerful concepts.\n\nHappy Coding!",
    "feature_image": "/content/images/2019/12/call-apply-bind.png",
    "featured": 1,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2019-07-02 17:04:58",
    "updated_at": "2019-12-02 00:38:54",
    "published_at": "2019-07-02 22:06:01",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7f0",
    "uuid": "df2870f6-6e4f-4a6d-8c0a-0f6d8bdeb1a3",
    "title": "My journey into SpringBoot with Kotlin",
    "slug": "my-journey-into-springboot-with-kotlin",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[[\"soft-return\",\"\",{}],[\"soft-return\",\"\",{}]],\"cards\":[[\"code\",{\"code\":\"    //InvoiceModel.java\\n   \\n    public class InvoiceModel {\\n        private String fullName;\\n        private String invoicedate;\\n        private String term;\\n        private List<InvoiceData> invoiceDatas;\\n        private Integer breakfasttotal;\\n        private Integer lunchtotal;\\n        private Integer afterSchooltotal;\\n        private double breakfastamount;\\n        private double lunchamount;\\n        private double afterschoolamount;\\n        private double totaldue;\\n        private double breakfastprice;\\n        private double lunchprice;\\n        private double afterschoolprice;\\n\\n        public InvoiceModel(String fullName, String invoicedate, String term, List<InvoiceData> invoiceDatas,\\n                Integer breakfasttotal, Integer lunchtotal, Integer afterSchooltotal, double breakfastamount,\\n                double lunchamount, double afterschoolamount, double totaldue, double breakfastprice, double lunchprice,\\n                double afterschoolprice) {\\n            super();\\n            this.fullName = fullName;\\n            this.invoicedate = invoicedate;\\n            this.term = term;\\n            this.invoiceDatas = invoiceDatas;\\n            this.breakfasttotal = breakfasttotal;\\n            this.lunchtotal = lunchtotal;\\n            this.afterSchooltotal = afterSchooltotal;\\n            this.breakfastamount = breakfastamount;\\n            this.lunchamount = lunchamount;\\n            this.afterschoolamount = afterschoolamount;\\n            this.totaldue = totaldue;\\n            this.breakfastprice = breakfastprice;\\n            this.lunchprice = lunchprice;\\n            this.afterschoolprice = afterschoolprice;\\n        }\\n\\n        public String getFullName() {\\n            return fullName;\\n        }\\n\\n        public void setFullName(String fullName) {\\n            this.fullName = fullName;\\n        }\\n\\n        public String getInvoicedate() {\\n            return invoicedate;\\n        }\\n\\n        public void setInvoicedate(String invoicedate) {\\n            this.invoicedate = invoicedate;\\n        }\\n\\n        public String getTerm() {\\n            return term;\\n        }\\n\\n        public void setTerm(String term) {\\n            this.term = term;\\n        }\\n\\n        public List<InvoiceData> getInvoiceDatas() {\\n            return invoiceDatas;\\n        }\\n\\n        public void setInvoiceDatas(List<InvoiceData> invoiceDatas) {\\n            this.invoiceDatas = invoiceDatas;\\n        }\\n\\n        public Integer getBreakfasttotal() {\\n            return breakfasttotal;\\n        }\\n\\n        public void setBreakfasttotal(Integer breakfasttotal) {\\n            this.breakfasttotal = breakfasttotal;\\n        }\\n\\n        public Integer getLunchtotal() {\\n            return lunchtotal;\\n        }\\n\\n        public void setLunchtotal(Integer lunchtotal) {\\n            this.lunchtotal = lunchtotal;\\n        }\\n\\n        public Integer getAfterSchooltotal() {\\n            return afterSchooltotal;\\n        }\\n\\n        public void setAfterSchooltotal(Integer afterSchooltotal) {\\n            this.afterSchooltotal = afterSchooltotal;\\n        }\\n\\n        public double getBreakfastamount() {\\n            return breakfastamount;\\n        }\\n\\n        public void setBreakfastamount(double breakfastamount) {\\n            this.breakfastamount = breakfastamount;\\n        }\\n\\n        public double getLunchamount() {\\n            return lunchamount;\\n        }\\n\\n        public void setLunchamount(double lunchamount) {\\n            this.lunchamount = lunchamount;\\n        }\\n\\n        public double getAfterschoolamount() {\\n            return afterschoolamount;\\n        }\\n\\n        public void setAfterschoolamount(double afterschoolamount) {\\n            this.afterschoolamount = afterschoolamount;\\n        }\\n\\n        public double getTotaldue() {\\n            return totaldue;\\n        }\\n\\n        public void setTotaldue(double totaldue) {\\n            this.totaldue = totaldue;\\n        }\\n\\n        public double getBreakfastprice() {\\n            return breakfastprice;\\n        }\\n\\n        public void setBreakfastprice(double breakfastprice) {\\n            this.breakfastprice = breakfastprice;\\n        }\\n\\n        public double getLunchprice() {\\n            return lunchprice;\\n        }\\n\\n        public void setLunchprice(double lunchprice) {\\n            this.lunchprice = lunchprice;\\n        }\\n\\n        public double getAfterschoolprice() {\\n            return afterschoolprice;\\n        }\\n\\n        public void setAfterschoolprice(double afterschoolprice) {\\n            this.afterschoolprice = afterschoolprice;\\n        }\\n    }\\n\",\"language\":\"Java\",\"caption\":\"\"}],[\"code\",{\"code\":\"    // InvoiceModel.kt\\n    data class InvoiceModel(\\n        var fullName: String, \\n        var invoicedate: String, \\n        var term: String,\\n        var invoiceDatas: List<InvoiceData>,\\n        var breakfasttotal: Int,\\n        var lunchtotal: Int,\\n        var afterSchooltotal: Int,\\n        var breakfastamount: Double,\\n        var lunchamount: Double,\\n        var afterschoolamount: Double,\\n        var totaldue: Double,\\n        var breakfastprice: Double,\\n        var lunchprice: Double,\\n        var afterschoolprice: Double\\n    )\",\"language\":\"Java\"}],[\"html\",{\"html\":\"<img class=\\\"rounded mx-auto d-block\\\" src=\\\"https://media2.giphy.com/media/NiOPyn6a7tV3q/giphy.gif?cid=790b76115d1ee35a73434b33592fadde&amp;rid=giphy.gif\\\" alt=\\\"queue reaction s GIF\\\" style=\\\"width: 480px; height: 270.4px; margin: auto;\\\">\"}],[\"html\",{\"html\":\"<p class=\\\"space\\\"></p>\"}],[\"html\",{\"html\":\"<p class=\\\"post-sub-title\\\">Convention over Configuration</p>\"}],[\"html\",{\"html\":\"<p class=\\\"post-sub-title\\\">Dependency Injection</p>\"}],[\"html\",{\"html\":\"<p class=\\\"post-sub-title\\\">Modular Boilerplate Code</p>\"}],[\"markdown\",{\"markdown\":\"You can generate your Spring Boot boiler code at [http://start.spring.io](http://start.spring.io) to build the tempplate for your project and you can make it as modular as you want. They include but not limited to:\\n* Spring Data\\n* Spring Security\\n* Spring MVC and much more...\"}],[\"html\",{\"html\":\"<p class=\\\"post-sub-title\\\">Conclusion</p>\"}]],\"markups\":[[\"em\"],[\"strong\"]],\"sections\":[[1,\"p\",[[0,[],0,\"I have been an adept C# .Net-ter and always will be. One of my favourites is still C# .NET Core as I do C# almost on a daily basis, but a side of me wanted to be platform and framework agnostics as much as I can. I have been taking advantage of tradeoffs in the different languages/framework in developing micro-services. Some argue that you've got to master one language really well and then one framework really well. I say, You can master them all, be proficient and be able to develop production ready applications. In my case, I currently do .Net Core (MVC/Web API), Spring Boot (Java, Kotlin \"],[0,[0],1,\"(preferred)\"],[0,[],0,\"), Python (Django, Flask\"],[0,[0],1,\"(preferred)\"],[0,[],0,\"), JavaScript/TypeScript is also worth mentioning, but that's another topic for another day. In a future post, I shall detail a small project using all these technology and framework in a  architecture of micro-services . As I sink my feet more into the world of micro-services, and the plethora of technologies that can come together and function as a big ol system, it is a fascinating and yet intriguing experience. Having had a strong Java programming experience under my belt, I was able to get started quickly with Kotlin and the transition is almost none existent. I'd say flawless. I have been using Kotlin in production at work and it's a pure joy to work with in comparison to Java. An analogy to explain Kotlin vs Java would be taking the elevator or using the stairs to get to the 100th floor of a building, and Kotlin is the elevator. One catch is that Kotlin compiles to Java in the background. More also, Kotlin and Java can interop really well. You can extend your existing Java codes with Kotlin or mix-match them.\"]]],[1,\"p\",[[1,[],0,0],[0,[],0,\"With the knowledge of Java, I do catch myself inspecting the compiled Java code to see the nitty-gritty of what's happening under the hood when I come across some not so understandable Kotlin syntax. No matter how Kotlin syntax looks on IntelliJ Idea, my god, it's still beautiful wow!\"]]],[1,\"p\",[[1,[],0,1],[0,[],0,\"Let's say we want to create an InvoiceModel class that represents an invoice for a nursery. The properties of the class should allow for change or update. Let's see this in Java and Kotlin.\"]]],[10,0],[1,\"p\",[[0,[],0,\"\\t\\t\"]]],[1,\"p\",[[0,[],0,\"Now \"],[0,[0],1,\"Kotlin\\t\\t\"]]],[10,1],[1,\"p\",[[0,[],0,\"Just look at the beauty. Now compare the Java's 151 lines of code to Kotlin's 17 lines. Wow! Simply beautiful isn't it?\"]]],[10,2],[10,3],[10,4],[1,\"p\",[[0,[],0,\"Spring Boot abstracts all of the configuration you would have to do with the Spring framework. But if you would like to control or extend the default configurations, Spring Boot provides \"],[0,[0,1],2,\"application.properties\"],[0,[],0,\" for this purpose. \"]]],[10,5],[1,\"p\",[[0,[],0,\"Right out of the box, you get dependency injection for free with Spring Boot. The framework does this uplifting for you and you just worry about writing codes rather than registering your types explicitly like in .NET Core. Oh boy they got this right with Spring Boot.\"]]],[10,6],[10,7],[10,8],[1,\"p\",[[0,[],0,\"Getting started with the Spring framework using Spring Boot is very interesting if you already know Java as the framework is Java based, but came along Kotlin which makes it super fun to work with. You should easily get started with Kotlin if you are already comfortable with Java. You can learn Kotlin from scratch, but you will be better off knowing some Java at least the basics as most of the library and import you will be doing in Kotlin, are Java libraries. If  you want to get started with developing Java based enterprise application, the Spring framework via Spring Boot is matured to take you there and Kotlin over Java should be your choice. Future post will talk about how to get started with Spring Boot using Kotlin.  Happy Coding!\"]]]]}",
    "html": "<p>I have been an adept C# .Net-ter and always will be. One of my favourites is still C# .NET Core as I do C# almost on a daily basis, but a side of me wanted to be platform and framework agnostics as much as I can. I have been taking advantage of tradeoffs in the different languages/framework in developing micro-services. Some argue that you've got to master one language really well and then one framework really well. I say, You can master them all, be proficient and be able to develop production ready applications. In my case, I currently do .Net Core (MVC/Web API), Spring Boot (Java, Kotlin <em>(preferred)</em>), Python (Django, Flask<em>(preferred)</em>), JavaScript/TypeScript is also worth mentioning, but that's another topic for another day. In a future post, I shall detail a small project using all these technology and framework in a  architecture of micro-services . As I sink my feet more into the world of micro-services, and the plethora of technologies that can come together and function as a big ol system, it is a fascinating and yet intriguing experience. Having had a strong Java programming experience under my belt, I was able to get started quickly with Kotlin and the transition is almost none existent. I'd say flawless. I have been using Kotlin in production at work and it's a pure joy to work with in comparison to Java. An analogy to explain Kotlin vs Java would be taking the elevator or using the stairs to get to the 100th floor of a building, and Kotlin is the elevator. One catch is that Kotlin compiles to Java in the background. More also, Kotlin and Java can interop really well. You can extend your existing Java codes with Kotlin or mix-match them.</p><p><br>With the knowledge of Java, I do catch myself inspecting the compiled Java code to see the nitty-gritty of what's happening under the hood when I come across some not so understandable Kotlin syntax. No matter how Kotlin syntax looks on IntelliJ Idea, my god, it's still beautiful wow!</p><p><br>Let's say we want to create an InvoiceModel class that represents an invoice for a nursery. The properties of the class should allow for change or update. Let's see this in Java and Kotlin.</p><pre><code class=\"language-Java\">    //InvoiceModel.java\n   \n    public class InvoiceModel {\n        private String fullName;\n        private String invoicedate;\n        private String term;\n        private List&lt;InvoiceData&gt; invoiceDatas;\n        private Integer breakfasttotal;\n        private Integer lunchtotal;\n        private Integer afterSchooltotal;\n        private double breakfastamount;\n        private double lunchamount;\n        private double afterschoolamount;\n        private double totaldue;\n        private double breakfastprice;\n        private double lunchprice;\n        private double afterschoolprice;\n\n        public InvoiceModel(String fullName, String invoicedate, String term, List&lt;InvoiceData&gt; invoiceDatas,\n                Integer breakfasttotal, Integer lunchtotal, Integer afterSchooltotal, double breakfastamount,\n                double lunchamount, double afterschoolamount, double totaldue, double breakfastprice, double lunchprice,\n                double afterschoolprice) {\n            super();\n            this.fullName = fullName;\n            this.invoicedate = invoicedate;\n            this.term = term;\n            this.invoiceDatas = invoiceDatas;\n            this.breakfasttotal = breakfasttotal;\n            this.lunchtotal = lunchtotal;\n            this.afterSchooltotal = afterSchooltotal;\n            this.breakfastamount = breakfastamount;\n            this.lunchamount = lunchamount;\n            this.afterschoolamount = afterschoolamount;\n            this.totaldue = totaldue;\n            this.breakfastprice = breakfastprice;\n            this.lunchprice = lunchprice;\n            this.afterschoolprice = afterschoolprice;\n        }\n\n        public String getFullName() {\n            return fullName;\n        }\n\n        public void setFullName(String fullName) {\n            this.fullName = fullName;\n        }\n\n        public String getInvoicedate() {\n            return invoicedate;\n        }\n\n        public void setInvoicedate(String invoicedate) {\n            this.invoicedate = invoicedate;\n        }\n\n        public String getTerm() {\n            return term;\n        }\n\n        public void setTerm(String term) {\n            this.term = term;\n        }\n\n        public List&lt;InvoiceData&gt; getInvoiceDatas() {\n            return invoiceDatas;\n        }\n\n        public void setInvoiceDatas(List&lt;InvoiceData&gt; invoiceDatas) {\n            this.invoiceDatas = invoiceDatas;\n        }\n\n        public Integer getBreakfasttotal() {\n            return breakfasttotal;\n        }\n\n        public void setBreakfasttotal(Integer breakfasttotal) {\n            this.breakfasttotal = breakfasttotal;\n        }\n\n        public Integer getLunchtotal() {\n            return lunchtotal;\n        }\n\n        public void setLunchtotal(Integer lunchtotal) {\n            this.lunchtotal = lunchtotal;\n        }\n\n        public Integer getAfterSchooltotal() {\n            return afterSchooltotal;\n        }\n\n        public void setAfterSchooltotal(Integer afterSchooltotal) {\n            this.afterSchooltotal = afterSchooltotal;\n        }\n\n        public double getBreakfastamount() {\n            return breakfastamount;\n        }\n\n        public void setBreakfastamount(double breakfastamount) {\n            this.breakfastamount = breakfastamount;\n        }\n\n        public double getLunchamount() {\n            return lunchamount;\n        }\n\n        public void setLunchamount(double lunchamount) {\n            this.lunchamount = lunchamount;\n        }\n\n        public double getAfterschoolamount() {\n            return afterschoolamount;\n        }\n\n        public void setAfterschoolamount(double afterschoolamount) {\n            this.afterschoolamount = afterschoolamount;\n        }\n\n        public double getTotaldue() {\n            return totaldue;\n        }\n\n        public void setTotaldue(double totaldue) {\n            this.totaldue = totaldue;\n        }\n\n        public double getBreakfastprice() {\n            return breakfastprice;\n        }\n\n        public void setBreakfastprice(double breakfastprice) {\n            this.breakfastprice = breakfastprice;\n        }\n\n        public double getLunchprice() {\n            return lunchprice;\n        }\n\n        public void setLunchprice(double lunchprice) {\n            this.lunchprice = lunchprice;\n        }\n\n        public double getAfterschoolprice() {\n            return afterschoolprice;\n        }\n\n        public void setAfterschoolprice(double afterschoolprice) {\n            this.afterschoolprice = afterschoolprice;\n        }\n    }\n</code></pre><p>\t\t</p><p>Now <em>Kotlin\t\t</em></p><pre><code class=\"language-Java\">    // InvoiceModel.kt\n    data class InvoiceModel(\n        var fullName: String, \n        var invoicedate: String, \n        var term: String,\n        var invoiceDatas: List&lt;InvoiceData&gt;,\n        var breakfasttotal: Int,\n        var lunchtotal: Int,\n        var afterSchooltotal: Int,\n        var breakfastamount: Double,\n        var lunchamount: Double,\n        var afterschoolamount: Double,\n        var totaldue: Double,\n        var breakfastprice: Double,\n        var lunchprice: Double,\n        var afterschoolprice: Double\n    )</code></pre><p>Just look at the beauty. Now compare the Java's 151 lines of code to Kotlin's 17 lines. Wow! Simply beautiful isn't it?</p><!--kg-card-begin: html--><img class=\"rounded mx-auto d-block\" src=\"https://media2.giphy.com/media/NiOPyn6a7tV3q/giphy.gif?cid=790b76115d1ee35a73434b33592fadde&amp;rid=giphy.gif\" alt=\"queue reaction s GIF\" style=\"width: 480px; height: 270.4px; margin: auto;\"><!--kg-card-end: html--><!--kg-card-begin: html--><p class=\"space\"></p><!--kg-card-end: html--><!--kg-card-begin: html--><p class=\"post-sub-title\">Convention over Configuration</p><!--kg-card-end: html--><p>Spring Boot abstracts all of the configuration you would have to do with the Spring framework. But if you would like to control or extend the default configurations, Spring Boot provides <em><strong>application.properties</strong></em> for this purpose. </p><!--kg-card-begin: html--><p class=\"post-sub-title\">Dependency Injection</p><!--kg-card-end: html--><p>Right out of the box, you get dependency injection for free with Spring Boot. The framework does this uplifting for you and you just worry about writing codes rather than registering your types explicitly like in .NET Core. Oh boy they got this right with Spring Boot.</p><!--kg-card-begin: html--><p class=\"post-sub-title\">Modular Boilerplate Code</p><!--kg-card-end: html--><!--kg-card-begin: markdown--><p>You can generate your Spring Boot boiler code at <a href=\"http://start.spring.io\">http://start.spring.io</a> to build the tempplate for your project and you can make it as modular as you want. They include but not limited to:</p>\n<ul>\n<li>Spring Data</li>\n<li>Spring Security</li>\n<li>Spring MVC and much more...</li>\n</ul>\n<!--kg-card-end: markdown--><!--kg-card-begin: html--><p class=\"post-sub-title\">Conclusion</p><!--kg-card-end: html--><p>Getting started with the Spring framework using Spring Boot is very interesting if you already know Java as the framework is Java based, but came along Kotlin which makes it super fun to work with. You should easily get started with Kotlin if you are already comfortable with Java. You can learn Kotlin from scratch, but you will be better off knowing some Java at least the basics as most of the library and import you will be doing in Kotlin, are Java libraries. If  you want to get started with developing Java based enterprise application, the Spring framework via Spring Boot is matured to take you there and Kotlin over Java should be your choice. Future post will talk about how to get started with Spring Boot using Kotlin.  Happy Coding!</p>",
    "comment_id": "5d1e40aca38224549403f874",
    "plaintext": "I have been an adept C# .Net-ter and always will be. One of my favourites is\nstill C# .NET Core as I do C# almost on a daily basis, but a side of me wanted\nto be platform and framework agnostics as much as I can. I have been taking\nadvantage of tradeoffs in the different languages/framework in developing\nmicro-services. Some argue that you've got to master one language really well\nand then one framework really well. I say, You can master them all, be\nproficient and be able to develop production ready applications. In my case, I\ncurrently do .Net Core (MVC/Web API), Spring Boot (Java, Kotlin (preferred)),\nPython (Django, Flask(preferred)), JavaScript/TypeScript is also worth\nmentioning, but that's another topic for another day. In a future post, I shall\ndetail a small project using all these technology and framework in a\n architecture of micro-services . As I sink my feet more into the world of\nmicro-services, and the plethora of technologies that can come together and\nfunction as a big ol system, it is a fascinating and yet intriguing experience.\nHaving had a strong Java programming experience under my belt, I was able to get\nstarted quickly with Kotlin and the transition is almost none existent. I'd say\nflawless. I have been using Kotlin in production at work and it's a pure joy to\nwork with in comparison to Java. An analogy to explain Kotlin vs Java would be\ntaking the elevator or using the stairs to get to the 100th floor of a building,\nand Kotlin is the elevator. One catch is that Kotlin compiles to Java in the\nbackground. More also, Kotlin and Java can interop really well. You can extend\nyour existing Java codes with Kotlin or mix-match them.\n\n\nWith the knowledge of Java, I do catch myself inspecting the compiled Java code\nto see the nitty-gritty of what's happening under the hood when I come across\nsome not so understandable Kotlin syntax. No matter how Kotlin syntax looks on\nIntelliJ Idea, my god, it's still beautiful wow!\n\n\nLet's say we want to create an InvoiceModel class that represents an invoice for\na nursery. The properties of the class should allow for change or update. Let's\nsee this in Java and Kotlin.\n\n    //InvoiceModel.java\n   \n    public class InvoiceModel {\n        private String fullName;\n        private String invoicedate;\n        private String term;\n        private List<InvoiceData> invoiceDatas;\n        private Integer breakfasttotal;\n        private Integer lunchtotal;\n        private Integer afterSchooltotal;\n        private double breakfastamount;\n        private double lunchamount;\n        private double afterschoolamount;\n        private double totaldue;\n        private double breakfastprice;\n        private double lunchprice;\n        private double afterschoolprice;\n\n        public InvoiceModel(String fullName, String invoicedate, String term, List<InvoiceData> invoiceDatas,\n                Integer breakfasttotal, Integer lunchtotal, Integer afterSchooltotal, double breakfastamount,\n                double lunchamount, double afterschoolamount, double totaldue, double breakfastprice, double lunchprice,\n                double afterschoolprice) {\n            super();\n            this.fullName = fullName;\n            this.invoicedate = invoicedate;\n            this.term = term;\n            this.invoiceDatas = invoiceDatas;\n            this.breakfasttotal = breakfasttotal;\n            this.lunchtotal = lunchtotal;\n            this.afterSchooltotal = afterSchooltotal;\n            this.breakfastamount = breakfastamount;\n            this.lunchamount = lunchamount;\n            this.afterschoolamount = afterschoolamount;\n            this.totaldue = totaldue;\n            this.breakfastprice = breakfastprice;\n            this.lunchprice = lunchprice;\n            this.afterschoolprice = afterschoolprice;\n        }\n\n        public String getFullName() {\n            return fullName;\n        }\n\n        public void setFullName(String fullName) {\n            this.fullName = fullName;\n        }\n\n        public String getInvoicedate() {\n            return invoicedate;\n        }\n\n        public void setInvoicedate(String invoicedate) {\n            this.invoicedate = invoicedate;\n        }\n\n        public String getTerm() {\n            return term;\n        }\n\n        public void setTerm(String term) {\n            this.term = term;\n        }\n\n        public List<InvoiceData> getInvoiceDatas() {\n            return invoiceDatas;\n        }\n\n        public void setInvoiceDatas(List<InvoiceData> invoiceDatas) {\n            this.invoiceDatas = invoiceDatas;\n        }\n\n        public Integer getBreakfasttotal() {\n            return breakfasttotal;\n        }\n\n        public void setBreakfasttotal(Integer breakfasttotal) {\n            this.breakfasttotal = breakfasttotal;\n        }\n\n        public Integer getLunchtotal() {\n            return lunchtotal;\n        }\n\n        public void setLunchtotal(Integer lunchtotal) {\n            this.lunchtotal = lunchtotal;\n        }\n\n        public Integer getAfterSchooltotal() {\n            return afterSchooltotal;\n        }\n\n        public void setAfterSchooltotal(Integer afterSchooltotal) {\n            this.afterSchooltotal = afterSchooltotal;\n        }\n\n        public double getBreakfastamount() {\n            return breakfastamount;\n        }\n\n        public void setBreakfastamount(double breakfastamount) {\n            this.breakfastamount = breakfastamount;\n        }\n\n        public double getLunchamount() {\n            return lunchamount;\n        }\n\n        public void setLunchamount(double lunchamount) {\n            this.lunchamount = lunchamount;\n        }\n\n        public double getAfterschoolamount() {\n            return afterschoolamount;\n        }\n\n        public void setAfterschoolamount(double afterschoolamount) {\n            this.afterschoolamount = afterschoolamount;\n        }\n\n        public double getTotaldue() {\n            return totaldue;\n        }\n\n        public void setTotaldue(double totaldue) {\n            this.totaldue = totaldue;\n        }\n\n        public double getBreakfastprice() {\n            return breakfastprice;\n        }\n\n        public void setBreakfastprice(double breakfastprice) {\n            this.breakfastprice = breakfastprice;\n        }\n\n        public double getLunchprice() {\n            return lunchprice;\n        }\n\n        public void setLunchprice(double lunchprice) {\n            this.lunchprice = lunchprice;\n        }\n\n        public double getAfterschoolprice() {\n            return afterschoolprice;\n        }\n\n        public void setAfterschoolprice(double afterschoolprice) {\n            this.afterschoolprice = afterschoolprice;\n        }\n    }\n\n\n\n\nNow Kotlin\n\n    // InvoiceModel.kt\n    data class InvoiceModel(\n        var fullName: String, \n        var invoicedate: String, \n        var term: String,\n        var invoiceDatas: List<InvoiceData>,\n        var breakfasttotal: Int,\n        var lunchtotal: Int,\n        var afterSchooltotal: Int,\n        var breakfastamount: Double,\n        var lunchamount: Double,\n        var afterschoolamount: Double,\n        var totaldue: Double,\n        var breakfastprice: Double,\n        var lunchprice: Double,\n        var afterschoolprice: Double\n    )\n\nJust look at the beauty. Now compare the Java's 151 lines of code to Kotlin's 17\nlines. Wow! Simply beautiful isn't it?\n\n\n\nConvention over Configuration\n\nSpring Boot abstracts all of the configuration you would have to do with the\nSpring framework. But if you would like to control or extend the default\nconfigurations, Spring Boot provides application.properties for this purpose. \n\nDependency Injection\n\nRight out of the box, you get dependency injection for free with Spring Boot.\nThe framework does this uplifting for you and you just worry about writing codes\nrather than registering your types explicitly like in .NET Core. Oh boy they got\nthis right with Spring Boot.\n\nModular Boilerplate Code\n\nYou can generate your Spring Boot boiler code at http://start.spring.io to build\nthe tempplate for your project and you can make it as modular as you want. They\ninclude but not limited to:\n\n * Spring Data\n * Spring Security\n * Spring MVC and much more...\n\nConclusion\n\nGetting started with the Spring framework using Spring Boot is very interesting\nif you already know Java as the framework is Java based, but came along Kotlin\nwhich makes it super fun to work with. You should easily get started with Kotlin\nif you are already comfortable with Java. You can learn Kotlin from scratch, but\nyou will be better off knowing some Java at least the basics as most of the\nlibrary and import you will be doing in Kotlin, are Java libraries. If  you want\nto get started with developing Java based enterprise application, the Spring\nframework via Spring Boot is matured to take you there and Kotlin over Java\nshould be your choice. Future post will talk about how to get started with\nSpring Boot using Kotlin.  Happy Coding!",
    "feature_image": "/content/images/2019/12/kotlin.png",
    "featured": 1,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2019-07-04 18:08:44",
    "updated_at": "2019-12-02 00:35:42",
    "published_at": "2019-07-07 14:18:16",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7f1",
    "uuid": "3813aeae-4338-4ea4-b955-080867a193b1",
    "title": "Hey, do you even Full-Stack ?",
    "slug": "untitled",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[],\"sections\":[[1,\"p\",[]]]}",
    "html": null,
    "comment_id": "5d1e41e7a38224549403f87e",
    "plaintext": null,
    "feature_image": "/content/images/2019/07/fullstack.jpeg",
    "featured": 0,
    "type": "post",
    "status": "draft",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2019-07-04 18:13:59",
    "updated_at": "2019-07-04 18:17:10",
    "published_at": null,
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7f2",
    "uuid": "871d0713-d97e-465c-b9e0-ad4150843d18",
    "title": "Getting Started with SpringBoot using Kotlin",
    "slug": "getting-started-with-springboot-with-kotlin",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"markdown\",{\"markdown\":\"### What is Spring Boot ?\"}]],\"markups\":[],\"sections\":[[1,\"p\",[[0,[],0,\"Hey happy coders! if you have seen my post about my journey into Spring Boot, I highlighted a huge benefit of using the Spring Boot framework and in particular how Kotlin makes Java development a joy.\"]]],[1,\"p\",[[0,[],0,\"In this post, I will quickly show you how easy it is to get started with building application with Spring Boot using Kotlin.\"]]],[1,\"p\",[[0,[],0,\"But first, let's so some quick intro to Spring Boot.\"]]],[10,0],[1,\"p\",[]]]}",
    "html": "<p>Hey happy coders! if you have seen my post about my journey into Spring Boot, I highlighted a huge benefit of using the Spring Boot framework and in particular how Kotlin makes Java development a joy.</p><p>In this post, I will quickly show you how easy it is to get started with building application with Spring Boot using Kotlin.</p><p>But first, let's so some quick intro to Spring Boot.</p><!--kg-card-begin: markdown--><h3 id=\"whatisspringboot\">What is Spring Boot ?</h3>\n<!--kg-card-end: markdown-->",
    "comment_id": "5d21bb9ea38224549403fab8",
    "plaintext": "Hey happy coders! if you have seen my post about my journey into Spring Boot, I\nhighlighted a huge benefit of using the Spring Boot framework and in particular\nhow Kotlin makes Java development a joy.\n\nIn this post, I will quickly show you how easy it is to get started with\nbuilding application with Spring Boot using Kotlin.\n\nBut first, let's so some quick intro to Spring Boot.\n\nWhat is Spring Boot ?",
    "feature_image": null,
    "featured": 0,
    "type": "post",
    "status": "draft",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2019-07-07 09:30:06",
    "updated_at": "2019-07-07 09:34:06",
    "published_at": null,
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7f3",
    "uuid": "e643758e-69af-4147-a9cc-cc47790f2d9d",
    "title": "Time Complexity & Big-O Notation",
    "slug": "time-complexixity",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[],\"sections\":[[1,\"p\",[[0,[],0,\"Back at the university when this concept was introduce, I initially thought to myself, who cares as long as the code runs and sluggishness can be observed from the user and it most cases, I was right.\"]]],[1,\"p\",[[0,[],0,\"But hmm... big but here. Designing efficient algorithm goes a long way. In these blog series about Data Structures & Algorithms, I will be explaining really quick some Computer Science fundamentals.\"]]]]}",
    "html": "<p>Back at the university when this concept was introduce, I initially thought to myself, who cares as long as the code runs and sluggishness can be observed from the user and it most cases, I was right.</p><p>But hmm... big but here. Designing efficient algorithm goes a long way. In these blog series about Data Structures &amp; Algorithms, I will be explaining really quick some Computer Science fundamentals.</p>",
    "comment_id": "5d24f2d8a38224549403fc0c",
    "plaintext": "Back at the university when this concept was introduce, I initially thought to\nmyself, who cares as long as the code runs and sluggishness can be observed from\nthe user and it most cases, I was right.\n\nBut hmm... big but here. Designing efficient algorithm goes a long way. In these\nblog series about Data Structures & Algorithms, I will be explaining really\nquick some Computer Science fundamentals.",
    "feature_image": null,
    "featured": 0,
    "type": "post",
    "status": "draft",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2019-07-09 20:02:32",
    "updated_at": "2019-07-09 20:06:33",
    "published_at": null,
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7f4",
    "uuid": "589d28b2-3b83-493a-9037-75755bc23261",
    "title": "Sample Portfolio page",
    "slug": "sample-portfolio-page",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[[\"a\",[\"href\",\"https://blackrockdigital.github.io/startbootstrap-resume/\"]]],\"sections\":[[1,\"p\",[[0,[0],1,\"https://blackrockdigital.github.io/startbootstrap-resume/\"]]],[1,\"p\",[]]]}",
    "html": "<p><a href=\"https://blackrockdigital.github.io/startbootstrap-resume/\">https://blackrockdigital.github.io/startbootstrap-resume/</a></p>",
    "comment_id": "5d32fc68a38224549403fc2b",
    "plaintext": "https://blackrockdigital.github.io/startbootstrap-resume/",
    "feature_image": null,
    "featured": 0,
    "type": "post",
    "status": "draft",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2019-07-20 11:35:04",
    "updated_at": "2019-07-20 11:35:09",
    "published_at": null,
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7f5",
    "uuid": "d8114bfa-357b-44c7-9440-ad896b6d459b",
    "title": "Projects",
    "slug": "projects",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[],\"markups\":[],\"sections\":[[1,\"p\",[[0,[],0,\"Coming soon.....\"]]],[1,\"p\",[[0,[],0,\"This page will list upcoming projects am working on or plan on working. Currently planning the formats.\"]]],[1,\"p\",[[0,[],0,\"Come back soon. ;-)\"]]]]}",
    "html": "<p>Coming soon.....</p><p>This page will list upcoming projects am working on or plan on working. Currently planning the formats.</p><p>Come back soon. ;-)</p>",
    "comment_id": "5d34b846a38224549403fc33",
    "plaintext": "Coming soon.....\n\nThis page will list upcoming projects am working on or plan on working.\nCurrently planning the formats.\n\nCome back soon. ;-)",
    "feature_image": null,
    "featured": 0,
    "type": "page",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2019-07-21 19:08:54",
    "updated_at": "2019-07-21 19:15:31",
    "published_at": "2019-07-21 19:12:50",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}, {
    "id": "5de39b41f8a8fb467c04a7f6",
    "uuid": "48fea536-27a0-489b-98f1-998089a573c7",
    "title": "Domain Event Pattern",
    "slug": "untitled-2",
    "mobiledoc": "{\"version\":\"0.3.1\",\"atoms\":[],\"cards\":[[\"html\",{\"html\":\"<p class=\\\"space\\\"></p>\"}],[\"html\",{\"html\":\"<p class=\\\"space\\\"></p>\"}],[\"image\",{\"src\":\"https://hadihariri.com/images/dtmd-1.png\",\"alt\":\"\",\"title\":\"\",\"cardWidth\":\"\"}],[\"markdown\",{\"markdown\":\"Adapting Udi Dahan's [Domain Events Salvation](http://udidahan.com/2009/06/14/domain-events-salvation/) post to .Net Core implementation.\"}],[\"markdown\",{\"markdown\":\"### Raising Events with side effects within a system\"}],[\"html\",{\"html\":\"<p class=\\\"space\\\"></p>\"}],[\"markdown\",{\"markdown\":\"### The Domain Object\"}],[\"code\",{\"code\":\"    public class Order\\n    {\\n        public Guid OrderId { get; private set; }\\n        public DateTime OrderDate { get; private set; }\\n        public int NumberOfItems { get; set; }\\n        public string OrderName { get; private set; }\\n        \\n        public Order(int numberOfItems, string orderName)\\n        {\\n            OrderId = Guid.NewGuid();\\n            OrderDate = DateTime.UtcNow;\\n            NumberOfItems = numberOfItems;\\n            OrderName = orderName;\\n        }\\n\\n        public void OrderComplete()\\n        {\\n            DomainEvent.Raise(new OrderCompletedEvent(DateTime.UtcNow, this));\\n        }\\n    }\",\"language\":\"csharp\"}],[\"html\",{\"html\":\"<p class=\\\"space\\\"></p>\"}],[\"markdown\",{\"markdown\":\"### The OrderCompletedEvent\"}],[\"code\",{\"code\":\"    public class OrderCompletedEvent : IDomainEvent\\n    {\\n        public DateTime OrderCreatedDate { get; private set; }\\n        public Order Order { get; private set; }\\n        \\n        \\n        public OrderCompletedEvent(DateTime orderCreatedDate, Order order)\\n        {\\n            OrderCreatedDate = orderCreatedDate;\\n            Order = order;\\n        }\\n    }\",\"language\":\"csharp\"}],[\"code\",{\"code\":\"public interface IDomainEvent{}\",\"language\":\"csharp\"}],[\"html\",{\"html\":\"<p class=\\\"space\\\"></p>\"}],[\"code\",{\"code\":\"    public static class DomainEvent\\n    {\\n        [ThreadStatic]\\n        private static List<Delegate> _actions;\\n\\n        public static IServiceProvider _serviceProvider { get; set; }\\n\\n        \\n        public static void Register<T>(Action<T> callback) where T : IDomainEvent\\n        {\\n            _actions = _actions ?? new List<Delegate>();\\n            _actions.Add(callback);\\n        }\\n\\n        public static void ClearCallbacks()\\n        {\\n            _actions = null;\\n        }\\n\\n        public static void Raise<T>(T args) where T : IDomainEvent\\n        {\\n            if (_serviceProvider != null)\\n            {\\n                //Fetch all handler of this type from the IoC container and invoke their handle method.\\n                foreach (var handler in (IEnumerable<IDomainHandler<T>>)_serviceProvider\\n                    .GetService(typeof(IEnumerable<IDomainHandler<T>>)))\\n                {\\n                    handler.Hanle(args);\\n                }\\n            }\\n            \\n            if (_actions != null)\\n            {\\n                foreach (var action in _actions)\\n                {\\n                    if (action is Action<T>)\\n                    {\\n                        ((Action<T>) action)(args);\\n                    }\\n                }\\n            }\\n        }\\n    }\",\"language\":\"csharp\"}],[\"html\",{\"html\":\"<p class=\\\"space\\\"></p>\"}],[\"markdown\",{\"markdown\":\"### The Event Handlers\"}],[\"code\",{\"code\":\"    public class OrderCompleteHandler : IDomainHandler<OrderCompletedEvent>\\n    {\\n        public void Hanle(OrderCompletedEvent @event)\\n        {\\n            @event.Order.NumberOfItems = 100;\\n            Console.WriteLine($\\\"Order Information: \\\\n=======================\\\" +\\n                              $\\\"\\\\nOrder completed on {@event.OrderCreatedDate.ToShortDateString()} \\\" +\\n                              $\\\"at {@event.OrderCreatedDate:HH:mm:ss tt}\\\\nID: {@event.Order.OrderId}\\\" +\\n                              $\\\"\\\\nNumber of order items: {@event.Order.NumberOfItems}\\\" +\\n                              $\\\"\\\\n____________________________________\\\");\\n        }\\n    }\",\"language\":\"csharp\"}],[\"code\",{\"code\":\"    public interface IDomainHandler<T> where T : IDomainEvent\\n    {\\n        void Hanle(T @event);\\n    }\",\"language\":\"csharp\"}],[\"html\",{\"html\":\"<p class=\\\"space\\\"></p>\"}],[\"markdown\",{\"markdown\":\"### Putting it all together\"}],[\"code\",{\"code\":\"    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            //Set up the DI\\n            //Scan the assembly and register types that implements IDomainHandler interface with .Net Core IoC\\n            var serviceProvider = new ServiceCollection()\\n                .Scan( scan => scan\\n                    .FromAssemblyOf<StudentRegisteredHandler>()\\n                    .AddClasses(classes => \\n                        classes.AssignableTo(typeof(IDomainHandler<>)))\\n                    .AsImplementedInterfaces()\\n                ).BuildServiceProvider();\\n\\n            DomainEvent._serviceProvider = serviceProvider;\\n            \\n            //Create an order\\n            \\n            var newOrder = new Order(5, \\\"Amazon\\\");\\n            //Raise an order completed event\\n            newOrder.OrderComplete();\\n            \\n            \\n            var studentReg = new Student(Title.Mr, \\\"John\\\", \\\"Murphy\\\");\\n            studentReg.RegisterStudent();\\n            \\n            var emailSent = \\n                new Email(\\\"recipient@contact.com\\\", \\n                    \\\"sender@contact.com\\\", \\\"Event Message Subject\\\", \\n                    \\\"This is a short email to say thank you!\\\");\\n            emailSent.RaiseEmailSent();\\n\\n            Console.ReadKey();\\n        }\\n    }\",\"language\":\"csharp\"}],[\"code\",{\"code\":\"Order Information: \\n=======================\\nOrder completed on 09/14/2019 at 17:04:30 PM\\nID: 07fa61ed-d5b4-4ed4-9ee1-30e4971972e8\\nNumber of order items: 100\\n____________________________________\\nMr. John Murphy registration is now complete\\n_____________________________\\n\\nEmail to the address recipient@contact.com has been sent!\\n_________________________\\n\",\"language\":\"xml\"}],[\"html\",{\"html\":\"<p class=\\\"space\\\"></p>\"}],[\"markdown\",{\"markdown\":\"### Relationship to other patterns\"}]],\"markups\":[[\"a\",[\"href\",\"https://github.com/mcvavy/DomainEvent\"]],[\"em\"],[\"a\",[\"href\",\"https://github.com/khellang/Scrutor\"]],[\"strong\"]],\"sections\":[[1,\"p\",[[0,[],0,\"Domain Event pattern with in-built .Net Core IoC Container, scrutor and .Net Core console application. Source code for this post can be found \"],[0,[0],1,\"here\"]]],[1,\"p\",[[0,[],0,\"This post focuses on the abstract of Domain Event in Domain Driven Design (DDD) which is also a fundamental building block of microservices or eventing system.\"]]],[10,0],[1,\"blockquote\",[[0,[],0,\"An event is something that has happened in the past. A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of. The notified parts usually react somehow to the events.\"]]],[10,1],[1,\"h3\",[[0,[],0,\"Dependency Injection does not eliminate tight coupling\"]]],[1,\"p\",[[0,[],0,\"While this post is not specific to microservices, the domain event pattern can be implemented in any system to reduce tight coupling  between your services. An example would be an MVC controller with a lot of dependencies, services or repositories injected via constructor injection.\"]]],[10,2],[10,3],[10,4],[1,\"p\",[[0,[],0,\"Without injecting any dependencies at compile time, any part of a system can have task completed without having prior knowledge of handler that would handle the commands. Some of the example we we would look at includes, completing an order by raising an event and having the proper handler located which will handle the event such as writing the order to a data store or sending an email to the customer.\"]]],[1,\"p\",[[0,[],0,\"In the interest of time we'll talk about a domain object and we'll see how that interacts with the system and you may refer to the source code further to see other examples or feel free to leave any questions.\"]]],[10,5],[1,\"p\",[]],[10,6],[10,7],[1,\"p\",[[0,[],0,\"The order domain object has a behavior such that when an order is created, it broadcasts an OrderCompletedEvent event of itself to the DomainEvent or Dispatcher and any handler that knows how to handle the event will respond and handles it. These handlers can also be referred to as Event Listeners or Subscribers.\"]]],[1,\"p\",[[0,[],0,\"The event is raised via the DomainEvent which is a static class. DomainEvent static class knows about all of the event handler and able to locate and invoke the right event handler for a given event. More about the DomainEvent shortly.\"]]],[10,8],[10,9],[10,10],[1,\"p\",[[0,[],0,\"The OrderCompletedEvent class implements an interface without any contract to implement merely decorating the class as a type called IDomainEvent.\"]]],[10,11],[1,\"p\",[[0,[],0,\"The OrderCompletedEvent has an instance of the Order object and it's duty is to transport the Order object along with any needed property or behavior to the handler.\"]]],[10,12],[1,\"h3\",[[0,[],0,\"The DomainEvent\"]]],[1,\"p\",[[0,[],0,\"The DomainEvent is responsible for some behaviors and they include\"]]],[1,\"blockquote\",[[0,[],0,\"Registering handler manually via its Register method\"]]],[1,\"blockquote\",[[0,[],0,\"Forwarding an event to the proper handler by iterating over all handlers for a particular type resolved from the IoC container\"]]],[1,\"p\",[[0,[],0,\"An IoC container is not required but imagine if you have to manually register tens of handlers in your system.\"]]],[10,13],[1,\"p\",[[0,[],0,\"The generic Raise<T> method in the DomainEvent static class iterates through all the handler using the resolved types from the IoC container.  The DomainEvent has to be bootstrapped on application startup taking in an instance of the IoC container or resolver. In the case of this application, takes an instance of ServiceProvider built from type registration on the instance of ServiceCollection. Don't pay attention to the ServiceProvider and ServiceCollection as they specific to .Net Core and you can choose to use any IoC container of your choice.\"]]],[10,14],[10,15],[1,\"p\",[[0,[],0,\"The EventHandlers go into a separate project that mimics the Onion architecture. According to the onion architecture, the handlers fits into the Infrastructure layer as they most likely will interact with other services and data stores or carry out some infrastructure related tasks. You get the gist.\"]]],[1,\"blockquote\",[[0,[],0,\"OrderCompleteHandler.cs\"]]],[10,16],[1,\"p\",[[0,[],0,\"The event handler in this case, \"],[0,[1],1,\"OrderCompleteHandler \"],[0,[],0,\"knows to listens for and knows how to handle \"],[0,[1],1,\"OrderCompletedEvent \"],[0,[],0,\"we talked about earlier above. All handlers implement a generic IDomainHandler<T> which describes the general signature of an event handler. It will make more sense when we talk about gluing the whole pieces together  next.\"]]],[10,17],[10,18],[10,19],[1,\"p\",[[0,[],0,\"Rather than registering each handler or subscriber  on demand as they are created, an IoC container best suit this scenario by registering all types that implements IDomainHandler<T>. For this purpose, S\"],[0,[2],1,\"crutor\"],[0,[],0,\" has been used. Scrutor can tie itself into the .Net Core IoC container which provides extensibility to register decorators currently not possible with the in-built .Net Core IoC.\"]]],[1,\"p\",[[0,[],0,\"Since a .Net Core console application is used as our client, the bootstrap and type registration is setup in the main method of the console app's Program.cs class.\"]]],[10,20],[1,\"p\",[[0,[],0,\"Scrutor provides an extension method, \"],[0,[1],1,\"Scan\"],[0,[],0,\" on the IServiceCollection interface. using Scrutor, the assembly of type that implements IDomainHandler<T>  are scanned and registered with the .Net Core IoC container which becomes automatically available to the DomainEvent static class which its Raise<T> method uses to locate the proper handler for a particular event.\"]]],[1,\"p\",[[0,[],0,\"This post mainly focused on one example of raising an event from a Domain object using a DomainEvent static class which its Raise method taps into an IoC container to locate the handler. The output below shows three samples of events that are raised and handled. Check out the source code for reference.\"]]],[10,21],[10,22],[10,23],[3,\"ul\",[[[0,[3],1,\"Event Driven Architecture\"],[0,[],0,\": Event driven architecture provides higher decoupling of your system\"]],[[0,[3],1,\"CQRS: \"],[0,[],0,\"Command Query Responsibility Segregation (CQRS) uses eventing to boost decoupling  as well and its a very popular pattern. A very good implementation of the CQRS is the .net MediatR library.\"]]]],[1,\"p\",[[0,[],0,\"Hopefully, you have learned something today.\"]]],[1,\"p\",[[0,[],0,\"Happy coding..\"]]]]}",
    "html": "<p>Domain Event pattern with in-built .Net Core IoC Container, scrutor and .Net Core console application. Source code for this post can be found <a href=\"https://github.com/mcvavy/DomainEvent\">here</a></p><p>This post focuses on the abstract of Domain Event in Domain Driven Design (DDD) which is also a fundamental building block of microservices or eventing system.</p><!--kg-card-begin: html--><p class=\"space\"></p><!--kg-card-end: html--><blockquote>An event is something that has happened in the past. A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of. The notified parts usually react somehow to the events.</blockquote><!--kg-card-begin: html--><p class=\"space\"></p><!--kg-card-end: html--><h3 id=\"dependency-injection-does-not-eliminate-tight-coupling\">Dependency Injection does not eliminate tight coupling</h3><p>While this post is not specific to microservices, the domain event pattern can be implemented in any system to reduce tight coupling  between your services. An example would be an MVC controller with a lot of dependencies, services or repositories injected via constructor injection.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://hadihariri.com/images/dtmd-1.png\" class=\"kg-image\"></figure><!--kg-card-begin: markdown--><p>Adapting Udi Dahan's <a href=\"http://udidahan.com/2009/06/14/domain-events-salvation/\">Domain Events Salvation</a> post to .Net Core implementation.</p>\n<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><h3 id=\"raisingeventswithsideeffectswithinasystem\">Raising Events with side effects within a system</h3>\n<!--kg-card-end: markdown--><p>Without injecting any dependencies at compile time, any part of a system can have task completed without having prior knowledge of handler that would handle the commands. Some of the example we we would look at includes, completing an order by raising an event and having the proper handler located which will handle the event such as writing the order to a data store or sending an email to the customer.</p><p>In the interest of time we'll talk about a domain object and we'll see how that interacts with the system and you may refer to the source code further to see other examples or feel free to leave any questions.</p><!--kg-card-begin: html--><p class=\"space\"></p><!--kg-card-end: html--><p></p><!--kg-card-begin: markdown--><h3 id=\"thedomainobject\">The Domain Object</h3>\n<!--kg-card-end: markdown--><pre><code class=\"language-csharp\">    public class Order\n    {\n        public Guid OrderId { get; private set; }\n        public DateTime OrderDate { get; private set; }\n        public int NumberOfItems { get; set; }\n        public string OrderName { get; private set; }\n        \n        public Order(int numberOfItems, string orderName)\n        {\n            OrderId = Guid.NewGuid();\n            OrderDate = DateTime.UtcNow;\n            NumberOfItems = numberOfItems;\n            OrderName = orderName;\n        }\n\n        public void OrderComplete()\n        {\n            DomainEvent.Raise(new OrderCompletedEvent(DateTime.UtcNow, this));\n        }\n    }</code></pre><p>The order domain object has a behavior such that when an order is created, it broadcasts an OrderCompletedEvent event of itself to the DomainEvent or Dispatcher and any handler that knows how to handle the event will respond and handles it. These handlers can also be referred to as Event Listeners or Subscribers.</p><p>The event is raised via the DomainEvent which is a static class. DomainEvent static class knows about all of the event handler and able to locate and invoke the right event handler for a given event. More about the DomainEvent shortly.</p><!--kg-card-begin: html--><p class=\"space\"></p><!--kg-card-end: html--><!--kg-card-begin: markdown--><h3 id=\"theordercompletedevent\">The OrderCompletedEvent</h3>\n<!--kg-card-end: markdown--><pre><code class=\"language-csharp\">    public class OrderCompletedEvent : IDomainEvent\n    {\n        public DateTime OrderCreatedDate { get; private set; }\n        public Order Order { get; private set; }\n        \n        \n        public OrderCompletedEvent(DateTime orderCreatedDate, Order order)\n        {\n            OrderCreatedDate = orderCreatedDate;\n            Order = order;\n        }\n    }</code></pre><p>The OrderCompletedEvent class implements an interface without any contract to implement merely decorating the class as a type called IDomainEvent.</p><pre><code class=\"language-csharp\">public interface IDomainEvent{}</code></pre><p>The OrderCompletedEvent has an instance of the Order object and it's duty is to transport the Order object along with any needed property or behavior to the handler.</p><!--kg-card-begin: html--><p class=\"space\"></p><!--kg-card-end: html--><h3 id=\"the-domainevent\">The DomainEvent</h3><p>The DomainEvent is responsible for some behaviors and they include</p><blockquote>Registering handler manually via its Register method</blockquote><blockquote>Forwarding an event to the proper handler by iterating over all handlers for a particular type resolved from the IoC container</blockquote><p>An IoC container is not required but imagine if you have to manually register tens of handlers in your system.</p><pre><code class=\"language-csharp\">    public static class DomainEvent\n    {\n        [ThreadStatic]\n        private static List&lt;Delegate&gt; _actions;\n\n        public static IServiceProvider _serviceProvider { get; set; }\n\n        \n        public static void Register&lt;T&gt;(Action&lt;T&gt; callback) where T : IDomainEvent\n        {\n            _actions = _actions ?? new List&lt;Delegate&gt;();\n            _actions.Add(callback);\n        }\n\n        public static void ClearCallbacks()\n        {\n            _actions = null;\n        }\n\n        public static void Raise&lt;T&gt;(T args) where T : IDomainEvent\n        {\n            if (_serviceProvider != null)\n            {\n                //Fetch all handler of this type from the IoC container and invoke their handle method.\n                foreach (var handler in (IEnumerable&lt;IDomainHandler&lt;T&gt;&gt;)_serviceProvider\n                    .GetService(typeof(IEnumerable&lt;IDomainHandler&lt;T&gt;&gt;)))\n                {\n                    handler.Hanle(args);\n                }\n            }\n            \n            if (_actions != null)\n            {\n                foreach (var action in _actions)\n                {\n                    if (action is Action&lt;T&gt;)\n                    {\n                        ((Action&lt;T&gt;) action)(args);\n                    }\n                }\n            }\n        }\n    }</code></pre><p>The generic Raise&lt;T&gt; method in the DomainEvent static class iterates through all the handler using the resolved types from the IoC container.  The DomainEvent has to be bootstrapped on application startup taking in an instance of the IoC container or resolver. In the case of this application, takes an instance of ServiceProvider built from type registration on the instance of ServiceCollection. Don't pay attention to the ServiceProvider and ServiceCollection as they specific to .Net Core and you can choose to use any IoC container of your choice.</p><!--kg-card-begin: html--><p class=\"space\"></p><!--kg-card-end: html--><!--kg-card-begin: markdown--><h3 id=\"theeventhandlers\">The Event Handlers</h3>\n<!--kg-card-end: markdown--><p>The EventHandlers go into a separate project that mimics the Onion architecture. According to the onion architecture, the handlers fits into the Infrastructure layer as they most likely will interact with other services and data stores or carry out some infrastructure related tasks. You get the gist.</p><blockquote>OrderCompleteHandler.cs</blockquote><pre><code class=\"language-csharp\">    public class OrderCompleteHandler : IDomainHandler&lt;OrderCompletedEvent&gt;\n    {\n        public void Hanle(OrderCompletedEvent @event)\n        {\n            @event.Order.NumberOfItems = 100;\n            Console.WriteLine($\"Order Information: \\n=======================\" +\n                              $\"\\nOrder completed on {@event.OrderCreatedDate.ToShortDateString()} \" +\n                              $\"at {@event.OrderCreatedDate:HH:mm:ss tt}\\nID: {@event.Order.OrderId}\" +\n                              $\"\\nNumber of order items: {@event.Order.NumberOfItems}\" +\n                              $\"\\n____________________________________\");\n        }\n    }</code></pre><p>The event handler in this case, <em>OrderCompleteHandler </em>knows to listens for and knows how to handle <em>OrderCompletedEvent </em>we talked about earlier above. All handlers implement a generic IDomainHandler&lt;T&gt; which describes the general signature of an event handler. It will make more sense when we talk about gluing the whole pieces together  next.</p><pre><code class=\"language-csharp\">    public interface IDomainHandler&lt;T&gt; where T : IDomainEvent\n    {\n        void Hanle(T @event);\n    }</code></pre><!--kg-card-begin: html--><p class=\"space\"></p><!--kg-card-end: html--><!--kg-card-begin: markdown--><h3 id=\"puttingitalltogether\">Putting it all together</h3>\n<!--kg-card-end: markdown--><p>Rather than registering each handler or subscriber  on demand as they are created, an IoC container best suit this scenario by registering all types that implements IDomainHandler&lt;T&gt;. For this purpose, S<a href=\"https://github.com/khellang/Scrutor\">crutor</a> has been used. Scrutor can tie itself into the .Net Core IoC container which provides extensibility to register decorators currently not possible with the in-built .Net Core IoC.</p><p>Since a .Net Core console application is used as our client, the bootstrap and type registration is setup in the main method of the console app's Program.cs class.</p><pre><code class=\"language-csharp\">    class Program\n    {\n        static void Main(string[] args)\n        {\n            //Set up the DI\n            //Scan the assembly and register types that implements IDomainHandler interface with .Net Core IoC\n            var serviceProvider = new ServiceCollection()\n                .Scan( scan =&gt; scan\n                    .FromAssemblyOf&lt;StudentRegisteredHandler&gt;()\n                    .AddClasses(classes =&gt; \n                        classes.AssignableTo(typeof(IDomainHandler&lt;&gt;)))\n                    .AsImplementedInterfaces()\n                ).BuildServiceProvider();\n\n            DomainEvent._serviceProvider = serviceProvider;\n            \n            //Create an order\n            \n            var newOrder = new Order(5, \"Amazon\");\n            //Raise an order completed event\n            newOrder.OrderComplete();\n            \n            \n            var studentReg = new Student(Title.Mr, \"John\", \"Murphy\");\n            studentReg.RegisterStudent();\n            \n            var emailSent = \n                new Email(\"recipient@contact.com\", \n                    \"sender@contact.com\", \"Event Message Subject\", \n                    \"This is a short email to say thank you!\");\n            emailSent.RaiseEmailSent();\n\n            Console.ReadKey();\n        }\n    }</code></pre><p>Scrutor provides an extension method, <em>Scan</em> on the IServiceCollection interface. using Scrutor, the assembly of type that implements IDomainHandler&lt;T&gt;  are scanned and registered with the .Net Core IoC container which becomes automatically available to the DomainEvent static class which its Raise&lt;T&gt; method uses to locate the proper handler for a particular event.</p><p>This post mainly focused on one example of raising an event from a Domain object using a DomainEvent static class which its Raise method taps into an IoC container to locate the handler. The output below shows three samples of events that are raised and handled. Check out the source code for reference.</p><pre><code class=\"language-xml\">Order Information: \n=======================\nOrder completed on 09/14/2019 at 17:04:30 PM\nID: 07fa61ed-d5b4-4ed4-9ee1-30e4971972e8\nNumber of order items: 100\n____________________________________\nMr. John Murphy registration is now complete\n_____________________________\n\nEmail to the address recipient@contact.com has been sent!\n_________________________\n</code></pre><!--kg-card-begin: html--><p class=\"space\"></p><!--kg-card-end: html--><!--kg-card-begin: markdown--><h3 id=\"relationshiptootherpatterns\">Relationship to other patterns</h3>\n<!--kg-card-end: markdown--><ul><li><strong>Event Driven Architecture</strong>: Event driven architecture provides higher decoupling of your system</li><li><strong>CQRS: </strong>Command Query Responsibility Segregation (CQRS) uses eventing to boost decoupling  as well and its a very popular pattern. A very good implementation of the CQRS is the .net MediatR library.</li></ul><p>Hopefully, you have learned something today.</p><p>Happy coding..</p>",
    "comment_id": "5d7cd3104a4365250e0c0aa5",
    "plaintext": "Domain Event pattern with in-built .Net Core IoC Container, scrutor and .Net\nCore console application. Source code for this post can be found here\n[https://github.com/mcvavy/DomainEvent]\n\nThis post focuses on the abstract of Domain Event in Domain Driven Design (DDD)\nwhich is also a fundamental building block of microservices or eventing system.\n\n\n\n> An event is something that has happened in the past. A domain event is,\nsomething that happened in the domain that you want other parts of the same\ndomain (in-process) to be aware of. The notified parts usually react somehow to\nthe events.\n\n\nDependency Injection does not eliminate tight coupling\nWhile this post is not specific to microservices, the domain event pattern can\nbe implemented in any system to reduce tight coupling  between your services. An\nexample would be an MVC controller with a lot of dependencies, services or\nrepositories injected via constructor injection.\n\nAdapting Udi Dahan's Domain Events Salvation\n[http://udidahan.com/2009/06/14/domain-events-salvation/] post to .Net Core\nimplementation.\n\nRaising Events with side effects within a system\nWithout injecting any dependencies at compile time, any part of a system can\nhave task completed without having prior knowledge of handler that would handle\nthe commands. Some of the example we we would look at includes, completing an\norder by raising an event and having the proper handler located which will\nhandle the event such as writing the order to a data store or sending an email\nto the customer.\n\nIn the interest of time we'll talk about a domain object and we'll see how that\ninteracts with the system and you may refer to the source code further to see\nother examples or feel free to leave any questions.\n\n\n\n\n\nThe Domain Object\n    public class Order\n    {\n        public Guid OrderId { get; private set; }\n        public DateTime OrderDate { get; private set; }\n        public int NumberOfItems { get; set; }\n        public string OrderName { get; private set; }\n        \n        public Order(int numberOfItems, string orderName)\n        {\n            OrderId = Guid.NewGuid();\n            OrderDate = DateTime.UtcNow;\n            NumberOfItems = numberOfItems;\n            OrderName = orderName;\n        }\n\n        public void OrderComplete()\n        {\n            DomainEvent.Raise(new OrderCompletedEvent(DateTime.UtcNow, this));\n        }\n    }\n\nThe order domain object has a behavior such that when an order is created, it\nbroadcasts an OrderCompletedEvent event of itself to the DomainEvent or\nDispatcher and any handler that knows how to handle the event will respond and\nhandles it. These handlers can also be referred to as Event Listeners or\nSubscribers.\n\nThe event is raised via the DomainEvent which is a static class. DomainEvent\nstatic class knows about all of the event handler and able to locate and invoke\nthe right event handler for a given event. More about the DomainEvent shortly.\n\n\n\nThe OrderCompletedEvent\n    public class OrderCompletedEvent : IDomainEvent\n    {\n        public DateTime OrderCreatedDate { get; private set; }\n        public Order Order { get; private set; }\n        \n        \n        public OrderCompletedEvent(DateTime orderCreatedDate, Order order)\n        {\n            OrderCreatedDate = orderCreatedDate;\n            Order = order;\n        }\n    }\n\nThe OrderCompletedEvent class implements an interface without any contract to\nimplement merely decorating the class as a type called IDomainEvent.\n\npublic interface IDomainEvent{}\n\nThe OrderCompletedEvent has an instance of the Order object and it's duty is to\ntransport the Order object along with any needed property or behavior to the\nhandler.\n\n\n\nThe DomainEvent\nThe DomainEvent is responsible for some behaviors and they include\n\n> Registering handler manually via its Register method\n> Forwarding an event to the proper handler by iterating over all handlers for a\nparticular type resolved from the IoC container\nAn IoC container is not required but imagine if you have to manually register\ntens of handlers in your system.\n\n    public static class DomainEvent\n    {\n        [ThreadStatic]\n        private static List<Delegate> _actions;\n\n        public static IServiceProvider _serviceProvider { get; set; }\n\n        \n        public static void Register<T>(Action<T> callback) where T : IDomainEvent\n        {\n            _actions = _actions ?? new List<Delegate>();\n            _actions.Add(callback);\n        }\n\n        public static void ClearCallbacks()\n        {\n            _actions = null;\n        }\n\n        public static void Raise<T>(T args) where T : IDomainEvent\n        {\n            if (_serviceProvider != null)\n            {\n                //Fetch all handler of this type from the IoC container and invoke their handle method.\n                foreach (var handler in (IEnumerable<IDomainHandler<T>>)_serviceProvider\n                    .GetService(typeof(IEnumerable<IDomainHandler<T>>)))\n                {\n                    handler.Hanle(args);\n                }\n            }\n            \n            if (_actions != null)\n            {\n                foreach (var action in _actions)\n                {\n                    if (action is Action<T>)\n                    {\n                        ((Action<T>) action)(args);\n                    }\n                }\n            }\n        }\n    }\n\nThe generic Raise<T> method in the DomainEvent static class iterates through all\nthe handler using the resolved types from the IoC container.  The DomainEvent\nhas to be bootstrapped on application startup taking in an instance of the IoC\ncontainer or resolver. In the case of this application, takes an instance of\nServiceProvider built from type registration on the instance of\nServiceCollection. Don't pay attention to the ServiceProvider and\nServiceCollection as they specific to .Net Core and you can choose to use any\nIoC container of your choice.\n\n\n\nThe Event Handlers\nThe EventHandlers go into a separate project that mimics the Onion architecture.\nAccording to the onion architecture, the handlers fits into the Infrastructure\nlayer as they most likely will interact with other services and data stores or\ncarry out some infrastructure related tasks. You get the gist.\n\n> OrderCompleteHandler.cs\n    public class OrderCompleteHandler : IDomainHandler<OrderCompletedEvent>\n    {\n        public void Hanle(OrderCompletedEvent @event)\n        {\n            @event.Order.NumberOfItems = 100;\n            Console.WriteLine($\"Order Information: \\n=======================\" +\n                              $\"\\nOrder completed on {@event.OrderCreatedDate.ToShortDateString()} \" +\n                              $\"at {@event.OrderCreatedDate:HH:mm:ss tt}\\nID: {@event.Order.OrderId}\" +\n                              $\"\\nNumber of order items: {@event.Order.NumberOfItems}\" +\n                              $\"\\n____________________________________\");\n        }\n    }\n\nThe event handler in this case, OrderCompleteHandler knows to listens for and\nknows how to handle OrderCompletedEvent we talked about earlier above. All\nhandlers implement a generic IDomainHandler<T> which describes the general\nsignature of an event handler. It will make more sense when we talk about gluing\nthe whole pieces together  next.\n\n    public interface IDomainHandler<T> where T : IDomainEvent\n    {\n        void Hanle(T @event);\n    }\n\n\n\nPutting it all together\nRather than registering each handler or subscriber  on demand as they are\ncreated, an IoC container best suit this scenario by registering all types that\nimplements IDomainHandler<T>. For this purpose, Scrutor\n[https://github.com/khellang/Scrutor] has been used. Scrutor can tie itself into\nthe .Net Core IoC container which provides extensibility to register decorators\ncurrently not possible with the in-built .Net Core IoC.\n\nSince a .Net Core console application is used as our client, the bootstrap and\ntype registration is setup in the main method of the console app's Program.cs\nclass.\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //Set up the DI\n            //Scan the assembly and register types that implements IDomainHandler interface with .Net Core IoC\n            var serviceProvider = new ServiceCollection()\n                .Scan( scan => scan\n                    .FromAssemblyOf<StudentRegisteredHandler>()\n                    .AddClasses(classes => \n                        classes.AssignableTo(typeof(IDomainHandler<>)))\n                    .AsImplementedInterfaces()\n                ).BuildServiceProvider();\n\n            DomainEvent._serviceProvider = serviceProvider;\n            \n            //Create an order\n            \n            var newOrder = new Order(5, \"Amazon\");\n            //Raise an order completed event\n            newOrder.OrderComplete();\n            \n            \n            var studentReg = new Student(Title.Mr, \"John\", \"Murphy\");\n            studentReg.RegisterStudent();\n            \n            var emailSent = \n                new Email(\"recipient@contact.com\", \n                    \"sender@contact.com\", \"Event Message Subject\", \n                    \"This is a short email to say thank you!\");\n            emailSent.RaiseEmailSent();\n\n            Console.ReadKey();\n        }\n    }\n\nScrutor provides an extension method, Scan on the IServiceCollection interface.\nusing Scrutor, the assembly of type that implements IDomainHandler<T>  are\nscanned and registered with the .Net Core IoC container which becomes\nautomatically available to the DomainEvent static class which its Raise<T>\nmethod uses to locate the proper handler for a particular event.\n\nThis post mainly focused on one example of raising an event from a Domain object\nusing a DomainEvent static class which its Raise method taps into an IoC\ncontainer to locate the handler. The output below shows three samples of events\nthat are raised and handled. Check out the source code for reference.\n\nOrder Information: \n=======================\nOrder completed on 09/14/2019 at 17:04:30 PM\nID: 07fa61ed-d5b4-4ed4-9ee1-30e4971972e8\nNumber of order items: 100\n____________________________________\nMr. John Murphy registration is now complete\n_____________________________\n\nEmail to the address recipient@contact.com has been sent!\n_________________________\n\n\n\n\nRelationship to other patterns\n * Event Driven Architecture: Event driven architecture provides higher\n   decoupling of your system\n * CQRS: Command Query Responsibility Segregation (CQRS) uses eventing to boost\n   decoupling  as well and its a very popular pattern. A very good\n   implementation of the CQRS is the .net MediatR library.\n\nHopefully, you have learned something today.\n\nHappy coding..",
    "feature_image": "/content/images/2019/12/domain-event-dispatcher.png",
    "featured": 1,
    "type": "post",
    "status": "published",
    "locale": null,
    "visibility": "public",
    "send_email_when_published": 0,
    "author_id": "1",
    "created_at": "2019-09-14 11:46:24",
    "updated_at": "2019-12-02 00:30:46",
    "published_at": "2019-09-14 17:12:38",
    "custom_excerpt": null,
    "codeinjection_head": null,
    "codeinjection_foot": null,
    "custom_template": null,
    "canonical_url": null
}]